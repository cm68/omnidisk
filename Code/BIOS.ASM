;TITLE	'+++ CP/M 2.2 BIOS FOR OMNI +++'
;PAGE	0
; DON'T FORGET TO CHANGE DATE IN "SIGNON" MESSAGE
;************************************************
;*												*
;*		   ****    ***    ***     ***			*
;*		   *   *    *    *   *   *   *			*
;*		   *   *    *    *   *   *				*
;*	  	   ****     *    *   *    ***			*
;*		   *   *    *    *   *       *			*
;*		   *   *    *    *   *   *   *			*
;*		   ****    ***    ***     ***			*
;*												*
;************************************************
;*												*
;*	PROPERTY OF:	FULCRUM COMPUTER PRODS		*
;*			451 ALLEN COURT						*
;*			HEALSBURG, CALIFORNIA				*
;*					 USA						*
;*												*
;*			  (707) 433-0202					*
;*												*
;************************************************
;*												*
;*	BIOS VERSION 5.1:							*
;*												*
;*	FOR USE WITH THE FULCRUM AMAZING (TAH,		*
;*	TAH, TAH, TAAAAAH) OMNIDISK CONTROLLER		*
;*												*
;************************************************
;*                     Installation Notes:		*
;************************************************
; Using DDT or Zsid:
; IBIOS.HEX
; R2580				(64 K model)
; G0
; A>SAVE 35 OMNIHD64.COM
;
; Dangerous Things To Get You In The Night.
; 	The cold boot code contains a section to change the
;	default skew facter from 2 TO 3 and uses logical device
;	assignments to know what device your changing.
;	THEREFORE, CHANGE THE LOGICAL ASSIGNMENTS IF YOU CHANGE
;	THE CPM DRIVE ASSIGNMENTS, OUCH.
;
;****************************************************
;                   	REVISION HISTORY			*
;****************************************************
;Fifth Rev date Mar 13, 1987
;	Added 5" drive --> E: 
;	changed to Shugart ST412
;	Two logical drives of 5 Meg each
;
;Fourth rev date July 29, 1986
;	Removed MPUZ Board equ.
;	This version is used for 3 setups:
;	1.	If HD$USE is FALSE then A:,B:,C:& D: Are Floppies
;	2.	If HD$USE is TRUE then A: & B: & E: & F: are 
;		floppies and C: & D: are the hard disk.
;--------------------------------------------------------------
;Current drive assignments are depend on the A$VERSION equate
;And the USE$8 and USE$5 equates.
;
;  if HD$USE equ FALSE AND USE$8 AND USE$5 are TRUE
;	A> 8" Floppy Disk   SSDD	Logical device 0	Physical 10
;	B> 8" Floppy Disk   SSDD	Logical device 1	Physical 11
;	C> 5" Floppy Disk   DSDD	Logical device 2	Physical 14
;   D> 5" Floppy Disk   DSDD	Logical device 3	Physical 15
;	E - P Not used			N/A			N/A
;
;  if HD$USE equ FALSE AND USE$8 equ TRUE AND USE$5 equ FALSE
;	A> 8" Floppy Disk   DSDD	Logical device 0	Physical 14
;	B> 8" Floppy Disk   DSDD	Logical device 1	Physical 15
;	C - P Not used			N/A			N/A
;
;  if HD$USE equ FALSE AND USE$8 equ FALSE AND USE$5 equ TRUE
;	A> 5" Floppy Disk   DSDD	Logical device 0	Physical 14
;	B> 5" Floppy Disk   DSDD	Logical device 1	Physical 15
;	C - P Not used			N/A			N/A
;
;  if HD$USE equ TRUE AND USE$8 AND USE$5 are TRUE
;	A> 8" Floppy Disk   SSDD	Logical device 0	Physical 10
;	B> 8" Floppy Disk   SSDD	Logical device 1	Physical 11
;	C> HD Shugart ST412  5M		Logical device 2	Physical 18
;	D> HD Shugart ST412  5M		Logical device 3	Physical 19
;	E> 5" Floppy Disk   DSDD	Logical device 4	Physical 14
;	F> 5" Floppy Disk   DSDD	Logical device 5	Physical 15
;	G - P Not used			N/A			N/A
;
;  if HD$USE equ TRUE AND USE$8 equ TRUE AND USE$5 equ FALSE
;	A> 8" Floppy Disk   SSDD	Logical device 0	Physical 14
;	B> 8" Floppy Disk   SSDD	Logical device 1	Physical 15
;	C> HD Shugart ST412  5M		Logical device 2	Physical 18
;	D> HD Shugart ST412  5M		Logical device 3	Physical 19
;	E - P Not used			N/A			N/A
;
;  if HD$USE equ TRUE AND USE$8 equ FALSE AND USE$5 equ TRUE
;	A> 5" Floppy Disk   SSDD	Logical device 0	Physical 14
;	B> 5" Floppy Disk   SSDD	Logical device 1	Physical 15
;	C> HD Shugart ST412  5M		Logical device 2	Physical 18
;	D> HD Shugart ST412  5M		Logical device 3	Physical 19
;	E - P Not used			N/A			N/A
;--------------------------------------------------------------
;Third  rev date July 8, 1986
;	added TM602S Hard disk
;Second rev date Jan 4, 86 
;	set dma true
;	removed undefined boards except MPUZ
;First rev date Nov 7, 85 
;	installed for my system
;AS RECEIVED:
;	WARM BOOT NO LONGER DIES IF A: DISK NOT READY
;	PROPER STATUS RETURNED FROM IOCONST
;	DPH GENERATOR USED IF NDISKS>4
;	PROPER RETRY IF ERROR DURING GETDPB
;	^C RESPONSE TO DISK ERROR MSG SETS A: DISK
;	SLOW$WRITE OPTION TO SAVE SPACE IN NON-DMA SYSTEMS
;	ADD RDRPUN CONDITIONAL ASM
;	ADD FD LOAD, STEP &C STUFF
;	ADD MULTIPLE-LOGICAL HARD DISK STUFF
;	ADD LEN BYTE BEFORE MEMORY DISK DPB

;********************************************************
;	AS RELEASED, THIS ASM FILE IS SET UP FOR			*
;	ASSEMBLY WITH THE CP/M (tm) "ASM" ASSEMBLER.		*
;														*
;	ANY COMMENTED EQUATE STARTING WITH					*
;		;<== 'COMMENT LINE'								*
;	CAN BE CHANGED BY YOU, ALL OTHERS ARE FIXED			*
;********************************************************

FALSE	EQU	0
TRUE	EQU	NOT FALSE

MSIZE	EQU	60		;<== MEMORY SIZE IN K-BYTES
REVNUM	EQU	51		;BIOS REV #
CPMREV	EQU	22		;CP/M REV #

;	"BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
;	OTHER THAN 16K (REFERRED TO AS "B" THROUGHOUT THE TEXT).

BIAS	EQU	(MSIZE-20)*1024 ;ADDR OFFSET FROM 3400H (20K SYSTEM)

CCP	EQU	3400H+BIAS		;BASE OF CCP 
BDOS	EQU	CCP+806H	;BASE OF BDOS 
BIOS	EQU	CCP+1600H	;BASE OF BIOS
CDISK	EQU	0004H		;CURRENT CPM DISK BUFFER (CONTENTS 0=A,..,15=P)
OFFSET	EQU	1F80H-BIOS	;DDT/SID BIOS OFFSET

; VARIOUS CONFIGURATION EQUATES FOR THE CONSOLE DEVICE -- MODIFY AS NEEDED
; SET ONLY ONE OF THE FOLLOWING EQUATES "TRUE" TO SELECT THE CPM CONSOLE 
; DEVICE IF YOURE IO DEVICE IS NOT LISTED HERE THEN YOU MUST MODIFY THE 
; IO DRIVERS FOR YOURE IO DEVICE

ISIO2	EQU		FALSE		;IMSAI SIO-2
CSS1	EQU		TRUE		;COMPUPRO SYSTEM SUPPORT 1

;
; Define AUTOEXEC command usage
; TRUE = Execute command on COLD BOOT
; FALSE = Nothing on COLD BOOT
;
AUTOCMD	EQU	FALSE
; *******************************************************
; *														*
; * If there is a command inserted here, it will be 	*
; * given if the auto feature is enabled.				*
; * 	For Example:									*
; *														*
; * cmdbeg db	'MBASIC MYPROG'							*
; *	cmdend db	0										*
; *														*
; * will execute Microsoft Basic, and Mbasic will		*
; * execute the "MYPROG" basic program.					*
; *******************************************************
	IF AUTOCMD
	ORG	CCP+8			;POINT TO CCP BUFFER
	DB	CMDEND-CMDBEG	;Length of command
CMDBEG:
	DB	''	;INITIAL COMMAND GOES HERE
CMDEND:
	DB 	0	;TERMINATOR
	ENDIF ;AUTOCMD

;
; Declare types of floppy disks are installed.
; At least ONE type must be defined.
;
USE$8		EQU	TRUE	;Use 8" floppy disk drives.
USE$5		EQU	TRUE	;Use 5" floppy drives.
QUAD$DENS	EQU	FALSE	;5" floppy drive is 80 tracks per side (96TPI)
BOOT$8		EQU	FALSE	;Boot drive is 8" floppy

;
; Use non-standard floppy SKEY to be compatible with Morrow Floppys Disks
;  NOTE: This only applies to 8" floppy drives.
;
SKEW$3		EQU	FALSE		;SKEW OF 3 FOR MORROW FORMAT SSDD 1024 8" FLOPPY

;
; Define use of Hard Disk's
;
HD$USE		EQU	FALSE		;<== SET FALSE IF NO HARD DISK ON OMNIDISK

;
; Use DMA or Programmed I/O disk access
;
DMA			EQU	TRUE		;<== TRUE IF DMA OPERATION FALSE FOR IO
;
;	IF "DMA EQU TRUE" THEN THE TOP 8 BITS OF THE 24-BIT ADDRESS
;	NEEDS TO BE SPECIFIED.  IF YOUR CPU DRIVES THE BUS WITH
;	ZEROS, THEN LEAVE THE FOLLOWING EQUATE ALONE.  IF YOUR CPU
;	DRIVES THE BUS WITH SOME STRANGE VALUE, THEN CHANGE THE
;	EQUATE TO MATCH.  IF YOUR CPU DOES NOT DRIVE THE TOP 8
;	ADDRESS BITS (SUCH AS THE W/W MPU-B) THEN A PROPERLY
;	TERMINATED BUS WILL HAVE 0FFH ON THESE BITS.  IF YOU ARE
;	NOT USING DMA OR YOUR MEMORY DOES NOT RESPOND TO EXTENDED
;	ADDRESSING THEN THIS VALUE DOES NOT MATTER.
;
;DMAEXT		EQU	0		;<== TOP 8 OF 24-BIT DMA ADDRESS
DMAEXT		EQU	0FFH
;
;	OMNIDISK DMA PRIORITY IS SET BY SOFTWARE, NOT BY A DIP SWITCH.
;
;	SELECT WHATEVER PRIORITY YOU DESIRE --
;	00H IS THE LOWEST, 0FH IS THE HIGHEST.
;
;	OMNIDISK RUNS WELL WITH THE LOWEST PRIORITY BECAUSE IT
;	IS NEVER DOING ANYTHING TIME-CRITICAL WHEN DMA IS USED.
;
;	THERE ARE ONLY THREE CASES WHERE THE OMNIDISK CONTROLLER USES
;	DMA.  (1) READ/WRITE OPERATIONS WHEN THE BIOS IS ASSEMBLED
;	WITH DMA=TRUE.  (2) ANY ACCESS TO THE MEMORY DISK, EVEN IF
;	THE BIOS IS ASSEMBLED WITH DMA=FALSE.  (3) THE OC$MOVM COMMAND
;	WHICH MOVES A BLOCK OF MEMORY USING DMA.  OC$MOVM IS NOT USED
;	BY THE BIOS OR ANY UTILITY FUNCTION PROVIDED BY W/W OR FULCRUM.
;
;	IF DMA IS BROKEN IN YOUR SYSTEM, AVOID THE ABOVE 3 CONDITIONS
;	AND ENJOY MOST OF THE OMNIDISK ADVANTAGES.
;
DMAPRI   	EQU	0Fh		;<== DMA PRIORITY
;
;******************************************************************************

;	DISK SYSTEM EQUATES (change with care if you wish to save space)
;
;	FLOPPY DISK CONFIGURATION PARAMETERS
;
;	WDELAY AND LDELAY ARE IN UNITS OF 1/4 SECOND
;	VALID RANGE FOR BOTH: 1..255
;	WDELAY SHOULD NOT BE MUCH MORE THAN 1.5 SECONDS (EQU 6)
;	WDELAY GIVES THE MAX TIME THAT UNWRITTEN DATA IS HELD
;		THIS PARAMETER ALSO APPLIES TO HARD DISK
;	LDELAY GIVES HEAD UNLOAD TIME
;		WITH DOOR LOCKS 5 SECONDS IS ABOUT RIGHT
;		WITH MANY 1/2 AND 1/3 HEIGHT DRIVES 30-60 SECONDS IS BETTER
;
;	STEP8 RANGE: 1..16 MS
;	STEP5 RANGE: 2..32 MS (INTERNALLY ROUNED UP TO EVEN)
;	LOADx AND SETLx RANGE: 0..255 MS (BUT MUST REFLECT FLOPPY DRIVE PARMS)
;
;	6 & 20 IN NEXT TWO EQUATES GIVE 1.5 SEC AND 5 SECONDS DELAYS
;
;	modifed for my machine SHUGARTS AND SEMIENS ts
; DO NOT MAKE THE STEP8 ANY LONGER THAN 6 (BOMBS THE SEMIENS DRIVE)
; OR ANY SHORTER (BOMBS THE SHURGARTS)
WDELAY		EQU	6		;<== DELAY (IN 250MS TICKS) HOLDING WRITES
LDELAY		EQU	20		;<== FD HEADS LOADED AFTER USE IN 250MS TICKS
STEP8		EQU	6		;<== 8" FD STEP RATE IN MS
LOAD8		EQU	35		;<== 8" FD HEAD LOAD TIME IN MS
SETL8		EQU	14		;<== 8" FD HEAD SETTLE TIME IN MS (AFTER SEEK)
STEP5		EQU	6		;<== 5" FD STEP RATE IN MS
LOAD5		EQU	8		;<== 5" FD HEAD LOAD TIME IN MS
SETL5		EQU	0		;<== 5" FD HEAD SETTLE TIME IN MS (AFTER SEEK)
;
;	HARD DISK CONFIGURATION PARAMETERS
;
;
;	HARD DISK SELECTION -- SELECT ONLY ONE
;
CMI5616		EQU	FALSE		;<==CMI     6 HEAD 256 CYLINDERS BUFFERED SEEK
CMI5619		EQU	FALSE		;<==CMI     6 HEAD 306 CYLINDERS BUFFERED SEEK
CDCWREN 	EQU	FALSE		;<==CDC	    5 HEAD 697 CYLINERS BUFFERED SEEK
HH612		EQU	FALSE		;<==MICRO SCIENCE 1/2 HEIGHT
IMI5006 	EQU	FALSE		;<==IMI     2 HEAD 306 CYLINDERS BUFFERED SEEK
IMI5012 	EQU	FALSE		;<==IMI     4 HEAD 306 CYLINDERS BUFFERED SEEK
IMI5018		EQU	FALSE		;<==IMI     6 HEAD 306 CYLINDERS BUFFERED SEEK
SA712		EQU	FALSE		;<==SHUGART 4 HEAD 306 CYLINDERS BUFFERED SEEK
SA1004		EQU	FALSE		;<==SHUGART 4 HEAD 256 CYLINDERS BUFFERED SEEK
SQ306		EQU	FALSE		;<==SYQUEST 2 HEAD 306 CYLINDERS REMOVABLE
ST206		EQU	FALSE		;<==SEGATE 2 HEAD 306 CYLINDERS BUFFERED SEEK
ST506		EQU	FALSE		;<==SEGATE 4 HEAD 153 CYLINDERS 3 MS STEP RATE
ST406		EQU	FALSE		;<==SEGATE 2 HEAD 306 CYLINDERS BUFFERED SEEK
ST412		EQU	FALSE		;<==SEGATE 4 HEAD 306 CYLINDERS BUFFERED SEEK
ST419		EQU	FALSE		;<==SEGATE 6 HEAD 306 CYLINDERS BUFFERED SEEK
ST225		EQU	TRUE		;<==SEGATE 4 HEAD 615 CYLINDERS BUFFERED SEEK 20MB
ST251		EQU	FALSE		;<==SEGATE 6 HEAD 820 CYLINDERS BUFFERED SEEK 40MB**
TM501		EQU	FALSE		;<==TANDON 2 HEAD 306 CYLINDERS BUFFERED SEEK
TM502		EQU	FALSE		;<==TANDON 4 HEAD 306 CYLINDERS BUFFERED SEEK
TM602S		EQU	FALSE		;<==TANDON 4 HEAD 153 CYLINDERS 3 MS STEP RATE
TM603S		EQU	FALSE		;<==TANDON 6 HEAD 153 CYLINDERS 3 MS STEP RATE
TM603SE		EQU	FALSE		;<==TANDON 6 HEAD 230 CYLINDERS 3 MS STEP RATE
;
;
;	SELECT THE TYPE OF WESTREN DIGITAL CONTROLLER YOU HAVE
;	IE WD1000-XX ARE CRC TYPE CONTROLLERS SET TO 20H
;	   WD1001-XX ARE ECC TYPE CONTROLLERS SET TO A0H
;	   WD1002-XX ARE ECC TYPE CONTROLLERS SET TO A0H
HD$CTLR 	EQU	0A0H		;<== 0A0H IF ECC CTLR ELSE 20H & NOTHING ELSE.
;
;
;	BASED ON ABOVE EQUATES, THE FOLLOWING SYMBOLS ARE DEFINED
;
; HD$STEP   STEP RATE 0..F ==> 0.0 .. 7.5mS
; HD$PCMP   PRE-COMP TO BE USED FOR GIVEN DISK TYPE
; HD$PCYL   NUMBER OF PHYSICAL CYLINDERS IN DEVICE
; HD$NHDS   NUMBERS OF PHYSICAL (READ/WRITE) HEADS IN DEVICE
;

	IF IMI5006 OR ST406 OR TM501 OR SQ306
HD$STEP		EQU	0
HD$PCMP		EQU	150
HD$PCYL		EQU	306
HD$NHDS		EQU	2
	ENDIF

	IF IMI5018 OR ST419
HD$STEP		EQU	0
HD$PCMP		EQU	150
HD$PCYL		EQU	306
HD$NHDS		EQU	6
	ENDIF

	IF IMI5012 OR ST412 OR TM502 OR SA712 OR HH612
HD$STEP		EQU	0
HD$PCMP		EQU	150
HD$PCYL		EQU	306
HD$NHDS		EQU	4
	ENDIF

	IF SA1004
HD$STEP		EQU	0
HD$PCMP		EQU	128
HD$PCYL		EQU	256
HD$NHDS		EQU	4
	ENDIF

	IF ST506
HD$STEP		EQU	8		;STEP IS 4 MILLASECOND FOR MINE
HD$PCMP		EQU	75
HD$PCYL		EQU	153
HD$NHDS		EQU	4
	ENDIF

	IF TM602S 
HD$STEP		EQU	6
HD$PCMP		EQU	75
HD$PCYL		EQU	153
HD$NHDS		EQU	4
	ENDIF

	IF TM603S
HD$STEP		EQU	6
HD$PCMP		EQU	75
HD$PCYL		EQU	153
HD$NHDS		EQU	6
	ENDIF

	IF TM603SE
HD$STEP		EQU	6
HD$PCMP		EQU	75
HD$PCYL		EQU	230
HD$NHDS		EQU	6
	ENDIF

	IF ST225
HD$STEP		EQU	0		;BUFFERED STEP
HD$PCMP		EQU	300		;300-614
HD$PCYL		EQU	307		;614/2
HD$NHDS		EQU	4		;4 HEADS
	ENDIF

	IF ST251
HD$STEP		EQU	0		;BUFFERED STEP
HD$PCMP		EQU	205
HD$PCYL		EQU	409		;819/2
HD$NHDS		EQU	6		;6 HEADS
	ENDIF

; ---------

; Total number of logical disk drives.

FD$USE		SET	FALSE	;<== SET FALSE IF NO FLOPPY DISKS ON OMNIDISK
DRV$ABCD	SET	FALSE
NFDISKS		SET	0

	IF USE$8 OR USE$5
FD$USE		SET	TRUE	;<== SET TRUE IF FLOPPY DISKS ON OMNIDISK
NFDISKS		SET	2		;A:, B:
	ENDIF
	IF FD$USE AND (USE$8 AND USE$5)
DRV$ABCD	SET	TRUE
NFDISKS		SET	4 		; A:, B:, C:, D:
	ENDIF
	IF NOT HD$USE
NHDISKS		EQU	0
	ENDIF
	IF HD$USE
NHDISKS 	EQU	2		; C:, D:
	ENDIF

NDISKS		EQU	NFDISKS + NHDISKS	;<== NUMBER OF LOGICAL HARD DISK DRIVES

; --------

;
;	NOTE TO OMNIDISK USERS:
;
;	WE ARE SORRY THAT THE HARD DISK DEFINATION TABLES ARE SUCH A ZOO.
;	THERE WERE SEVERAL CONFLICTING DESIGN OBJECTIVES AND ABILITY TO USE
;	THE STANDARD DR "ASM" ASSEMBLER WON OUT OVER A MACRO OR TWO THAT
;	WOULD HAVE MADE YOUR TASK EASIER.
;
;	IF YOU HAVE ONLY ONE HARD DISK, AND THAT HARD IS CONFIGURED AS ONLY
;	ONE LOGICAL UNIT, THEN ALL WILL BE AUTOMATIC.
;
;	WHATEVER YOU DO, PLEASE REMEMBER THAT IN THE EQUATES FOR ALL THOSE
;	ALV$x, CKV$x AND DEV$x YOU ALSO NEED TO DEFINE HDLU$n AND TO USE
;	THAT VALUE IN THE OC$HDTB INIT CODE.
;
;	IF YOU HAVE A LARGE HARD DISK AND NEED SEVERAL LOGICAL DEVICES,
;	THEN YOU NEED TO DEFINE THE SIZE OF EACH PIECE.  THE SYMBOL
;	DEFINATIONS THAT FOLLOW JUST MAY BE OF SOME USE.  SEE ALSO THE
;	USE OF HD$BASE0 AND HD$SIZE0 IN THE INIT SECTION.
;
;	IF ONE OR MORE OF YOUR HARD DISK SEGMENTS IS LESS THAN 8 MEG (1000
;	TRACKS OR 2000 ALLOCATION UNITS) THEN YOU CAN SAVE ALLOCATION VECTOR
;	SPACE BY ASSURING THAT "ALV$x EQU (HD$SIZEn+3)/4" WHERE x IS THE CP/M
;	DRIVE LETTER (A: TO P:) AND n IS 0 TO 3 DEFINED BELOW.
;
;
HD$0		EQU	0H	;THESE VALUES SELECT THE PHYSICAL DRIVE 
HD$1		EQU	8H	;THAT A LOGICAL DRIVE RESIDES ON 
HD$2		EQU	10H	;AND ARE SELECTED IN THE TABLES BELOW
HD$3		EQU	18H	;FOR EACH LOGICAL DRIVE

HD$USE0		EQU	(NHDISKS+99)/100	;LOGICAL HARD DISK 0  (PLEASE SEE
HD$USE1		EQU	(NHDISKS+99)/101	;LOGICAL HARD DISK 1   BOTH USES
HD$USE2		EQU	(NHDISKS+99)/102	;LOGICAL HARD DISK 2   OF EACH OF
HD$USE3		EQU	(NHDISKS+99)/103	;LOGICAL HARD DISK 3   THESE SYMBOLS)

HD$SPACE 	SET	HD$PCYL*HD$NHDS
HD$ORG	 	SET	0
D$BASE0  	EQU	HD$ORG

;
;NOTE:
; HD$SIZE0 IS #CYL * #HEADS - 2 IF LESS THAN 1000 TRACK ON DRIVE
;
;MAX SIZE IS 8MB PER LOGICAL UNIT.
;

	IF HD$USE0
HD$SIZE0 	EQU	820			;<== 1000 TRACKS MAX FOR CP/M 2.2
HD$SEL0	 	EQU	HD$0		;<== SET FOR THE PHYSICAL HARD DRIVE SELECT
HD$BASE0 	EQU	HD$ORG
HD$SPACE 	SET	HD$SPACE-HD$SIZE0-2	;SPACE LEFT AFTER FIRST HARD DISK SEG
HD$ORG	 	SET	HD$ORG+HD$SIZE0+2	;ORG FOR NEXT LOGICAL HARD DISK
; NOTE: THE "-2" IS 2 TRACKS RESERVED FOR THE SYSTEM
	ENDIF

	IF HD$USE1
HD$SIZE1 	EQU	820			;<== SECOND SEGMENT SIZE
HD$SEL1	 	EQU	HD$0		;<== SET FOR THE PHYSICAL HARD DRIVE SELECT
HD$BASE1 	EQU	HD$ORG
HD$SPACE 	SET	HD$SPACE-HD$SIZE1-2	;SPACE LEFT AFTER SECOND HARD DISK SEG
HD$ORG	 	SET	HD$ORG+HD$SIZE1+2	;ORG FOR NEXT LOGICAL HARD DISK
	ENDIF

	IF HD$USE2
HD$SIZE2 	EQU	0			;<== THIRD SEGMENT SIZE
HD$SEL2	 	EQU	HD$0		;<== SET FOR THE PHYSICAL HRAD DISK
HD$BASE2 	EQU	HD$ORG
HD$SPACE 	SET	HD$SPACE-HD$SIZE2-2	;SPACE LEFT AFTER THIRD HARD DISK SEG
HD$ORG	 	SET	HD$ORG+HD$SIZE2+2	;ORG FOR NEXT LOGICAL HARD DISK
	ENDIF

	IF HD$USE3
HD$SIZE3 	EQU	0			;<== FOURTH SEGMENT SIZE
HD$SEL3	 	EQU	HD$0		;<== SET FOR THE PHYSICAL HARD DISK
HD$BASE3 	EQU	HD$ORG
HD$SPACE 	SET	HD$SPACE-HD$SIZE3-2	;SPACE LEFT AFTER FOURTH HARD DISK SEG
	ENDIF


;************************************************
;	BEGIN MEMORY DISK DEFINATION
;************************************************
;
MD$USE		EQU	FALSE		;<== CHANGE TO ASSEMBLE MEMORY DISK
;
;	REQUIRED READING FOR USERS OF THE MEMORY DISK --
;
;	ALL LINES IN THIS SECTION WITH ";<==" MUST BE READ AND UNDERSTOOD.
;	MAKE CHANGES TO REFLECT HOW YOUR SYSTEM IS CONFIGURED.
;
	IF	MD$USE
;
;	SIZE AND BASE OF MEMORY DISK BLOCKS --
;
;	YOU MAY HAVE UP TO 4 AREAS WITHIN THE S-100
;	ADDRESS SPACE THAT ARE TO BE USED AS MEMORY DISK.
;
;	THESE AREAS ARE DEFINED HERE IN TERMS OF 64K BLOCKS.
;	MD$Sx VALUES GIVE THE SIZE OR NUMBER OF 64K BLOCKS
;	IN THE GIVEN GROUP.  MD$Bx VALUES GIVE THE HIGH ORDER
;	8 BITS OF THE LOWEST ADDRESS IN THE GROUP.
;
MD$S1		EQU	4		;<== # 64K BLOCKS...
MD$B1		EQU	80H		;<== ...STARTING AT "MD$B1"0000H
MD$S2		EQU	0		;<== # 64K BLOCKS...
MD$B2		EQU	0		;<== ...STARTING AT "MD$B2"0000H
MD$S3		EQU	0		;<== # 64K BLOCKS...
MD$B3		EQU	0		;<== ...STARTING AT "MD$B3"0000H
MD$S4		EQU	0		;<== # 64K BLOCKS...
MD$B4		EQU	0		;<== ...STARTING AT "MD$B4"0000H
;
;	*************************************************
;	* ALL COMMENTS AND EQUATES FOR MEMORY DISK	*
;	* ASSUME 2K ALLOCATION SIZE.  THERE IS NOTHING	*
;	* IN THE OMNIDISK (tm) CONTROLLER THAT REQUIRES	*
;	* THIS.  FOR SMALL (64K OR 128K) MEMORY DISKS,	*
;	* A 1K ALLOCATION SIZE WOULD BE SLIGHTLY BETTER.*
;	* FOR LARGE (STARTING AT 1 OR 2 MEG) MEMORY	*
;	* DISKS, AN ALLOCATION SIZE OF 4K WOULD REDUCE	*
;	* SYSTEM MEMORY REQUIREMENTS BY ENOUGH TO MAKE	*
;	* THE CHANGE WORTH THE BOTHER.			*
;	*						*
;	* CONSULT THE DIGITAL RESEARCH CP/M ALTERATION	*
;	* GUIDE FOR REQUIRED KNOWLEDGE.			*
;	*************************************************
;
;	IF YOU HAVE MORE THAN 8 64K BLOCKS OF MEMORY DISK,
;	YOU MUST CHANGE THE FOLLOWING EQUATE.
;
MD$EXM		EQU	1		;<== CHANGE TO "EQU 0" IF > 512K MEMORY DISK
;
;	SETUP MEMORY DISK DIRECTORY SPACE --
;
;	PLEASE NOTE THAT HAVING MORE DIRECTORY SPACE THAN ALLOCATION
;	UNITS ONLY COSTS YOU SPACE.  SEE MD$AL BELOW.  DECIDE ON
;	A REASONABLE MAXIMUM NUMBER OF FILES, DIVIDE BY 32 TO GET
;	DIRECTORY SPACE IN BLOCKS.
;
;	THE MAXIMUM NUMBER OF DIRECTORY BLOCKS IS 16.  THIS GIVES
;	A MAXIMUM OF 512 FILE ENTRIES (USING 2K ALLOCATION SIZE).
;
;	SEE COMMENTS ON MD$Vxx EQUATES FOR THE MAXIMUM NUMBER OF FILE ENTRIES.
;
;	("NUMBER OF FILE ENTRIES" IS PERHAPS BETTER STATED AS "NUMBER OF
;	 EXTENTS".  THE MAXIMUM NUMBER OF FILES MAY BE SOMEWHAT LESS
;	 BECAUSE LARGE FILES TAKE MORE THAN ONE EXTENT.  ONE EXTENT
;	 IS 32K IF MD$EXM=0; THE EXTENT SIZE DROPS TO 16K IF MD$EXM=1.)
;
MD$DBLK		EQU	2		;<== NUMBER OF MEMORY DISK DIRECTORY BLOCKS
MD$FILES 	EQU	MD$DBLK*32
;
;	NOW SET THE DIRECTORY ALLOCATION VECTOR.
;
;	EQUATE MD$AL01 TO ONE OF THE FOLLOWING SYMBOLS
;
;							SUGGESTED
;					      FILES	MEM DSK SIZE
;					      -----	------------
MD$V1		EQU	00080H	;USE IF MD$DBLK = 1	 32	 64K - 128K
MD$V2		EQU	000C0H	;USE IF MD$DBLK = 2	 64	128K - 256K
MD$V3		EQU	000E0H	;USE IF MD$DBLK = 3	 96	192K - 512K
MD$V4		EQU	000F0H	;USE IF MD$DBLK = 4	128	256K - 1 MEG
MD$V5		EQU	000F8H	;USE IF MD$DBLK = 5	160	320K - 1.5 MEG
MD$V6		EQU	000FCH	;USE IF MD$DBLK = 6	192	394K - 2 MEG
MD$V7		EQU	000FEH	;USE IF MD$DBLK = 7	224	448K - 2.5 MEG
MD$V8		EQU	000FFH	;USE IF MD$DBLK = 8	256	512K - 3 MEG
MD$V9		EQU	080FFH	;USE IF MD$DBLK = 9	288	576K - 3.5 MEG
MD$V10		EQU	0C0FFH	;USE IF MD$DBLK = 10	320	640K - 4 MEG
MD$V11		EQU	0E0FFH	;USE IF MD$DBLK = 11	352	704K - 4.5 MEG
MD$V12		EQU	0F0FFH	;USE IF MD$DBLK = 12	384	768K - 5 MEG
MD$V13		EQU	0F8FFH	;USE IF MD$DBLK = 13	416	832K - 5.5 MEG
MD$V14		EQU	0FCFFH	;USE IF MD$DBLK = 14	448	896K - 6 MEG
MD$V15		EQU	0FEFFH	;USE IF MD$DBLK = 15	480	960K - 7 MEG
MD$V16		EQU	0FFFFH	;USE IF MD$DBLK = 16	512	1 MEG AND UP

MD$AL01		EQU	MD$V2	;<== ALLCATION BIT MAP FOR DIRECTORY
;
;	AGAIN, FOR...
;
;		MD$DBLK	 EQU	nn
;
;	THE ABOVE EQUATE MUST BE...
;
;		MD$AL01	 EQU	MD$Vnn
;
MD$SCYL		EQU	0		;<== "CYLINDERS" FOR SYSTEM ON MEMORY DISK
;
;	EACH "CYLINDER" IS 8K.  IF MD$SCYL=0 THEN NO SYSTEM IMAGE MAY BE
;	WRITTEN TO THE MEMORY DISK.  ONLY DISKS CONTAINING THE OPERATING
;	SYSTEM MAY BE ASSIGNED AS THE A: DISK.
;
MD$AL 		EQU  (MD$S1+MD$S2+MD$S3+MD$S4)*32-(4*MD$SCYL) ;MD SIZE IN 2K ALLOC UNITS

ALVMD		EQU	(MD$AL+7)/8	;ALLOC VECT (4 BYTES/64K)

; ALV$x	 EQU	ALVMD		;<== (DONT FORGET TO SETUP
; CKV$x	 EQU	CKVMD		;<==  A CP/M LOGICAL UNIT
; DEV$x	 EQU	MDISK		;<==  IN THE DRIVE TABLE)

	ENDIF ;MD$USE

;*********************************************
;	END OF MEMORY DISK DEFINATION
;*********************************************

;*********************************************
;	DISK SYSTEM EQUATES (change with care if you wish to save space)
;	ORIGINAL OMNIDISK 5" FLOPPY ALV5 EQU 38
	IF QUAD$DENS
ALV5		EQU	48		;MAX ALLOCATION VECTOR LENGTH FOR 5" FLOPPY
	ENDIF ;QUAD$DENS
	IF NOT QUAD$DENS
ALV5		EQU	38		;MAX ALLOCATION VECTOR LENGTH FOR 5" FLOPPY
	ENDIF ;NOT QUAD$DENS
ALV8		EQU	75		;MAX ALLOCATION VECTOR LENGTH FOR 8" FLOPPY
ALVHD		EQU	2000/8	;ALLOCATION VECTOR LENGTH FOR HARD DISK

CKV5		EQU	48		;5" FD CHECK VECTOR LENGTH (128 FILES)
CKV8		EQU	32		;8" FD CHECK VECTOR LENGTH (128 FILES)
CKVHD		EQU	0		;HARD DISK CHECK VECTOR NOT USED
CKVMD		EQU	0		;MEMORY DISK CHECK VECTOR NOT USED

FDISK8		EQU	10H		;OMNI DEV TYPE FOR 8" FLOPPY
FDISK5		EQU	14H		;OMNI DEV TYPE FOR 5" FLOPPY
HDISK		EQU	18H		;OMNI DEV TYPE FOR HARD DISK
MDISK		EQU	1CH		;OMNI DEV TYPE FOR MEMORY DISK

; --------- FLOPPY DISK LOGICAL UNITS

	IF FD$USE AND BOOT$8 AND DRV$ABCD
ALV$A		EQU	ALV8		;<== SET A: FOR 8"          
CKV$A		EQU	CKV8		;<== SET A: FOR 8"          
DEV$A		EQU	FDISK8+0	;<== SET A: FOR 8" UNIT 0   

ALV$B		EQU	ALV8		;<== SET B: FOR 8"
CKV$B		EQU	CKV8		;<== SET B: FOR 8"
DEV$B		EQU	FDISK8+1	;<== SET B: FOR 8" UNIT 1

ALV$C		EQU	ALV5		;<== SET C: FOR 5"
CKV$C		EQU	CKV5		;<== SET C: FOR 5"
DEV$C		EQU	FDISK5+0	;<== SET C: FOR 5" UNIT 0

ALV$D		EQU	ALV5		;<== SET D: FOR 5"
CKV$D		EQU	CKV5		;<== SET D: FOR 5"
DEV$D		EQU	FDISK5+1	;<== SET D: FOR 5" UNIT 1
	ENDIF ;FD$USE AND BOOT$8 AND DRV$ABCD
	IF FD$USE AND (NOT BOOT$8) AND DRV$ABCD
ALV$A		EQU	ALV5		;<== SET A: FOR 5"          
CKV$A		EQU	CKV5		;<== SET A: FOR 5"          
DEV$A		EQU	FDISK5+0	;<== SET A: FOR 5" UNIT 0   

ALV$B		EQU	ALV5		;<== SET B: FOR 5"
CKV$B		EQU	CKV5		;<== SET B: FOR 5"
DEV$B		EQU	FDISK5+1	;<== SET B: FOR 5" UNIT 1

ALV$C		EQU	ALV8		;<== SET C: FOR 8"
CKV$C		EQU	CKV8		;<== SET C: FOR 8"
DEV$C		EQU	FDISK8+0	;<== SET C: FOR 8" UNIT 0

ALV$D		EQU	ALV8		;<== SET D: FOR 8"
CKV$D		EQU	CKV8		;<== SET D: FOR 8"
DEV$D		EQU	FDISK8+1	;<== SET D: FOR 8" UNIT 1
	ENDIF ;FD$USE AND (NOT BOOT$8) AND DRV$ABCD
	IF FD$USE AND (USE$8 AND NOT USE$5)
ALV$A		EQU	ALV8		;<== SET A: FOR 8"          
CKV$A		EQU	CKV8		;<== SET A: FOR 8"          
DEV$A		EQU	FDISK8+0	;<== SET A: FOR 8" UNIT 0   

ALV$B		EQU	ALV8		;<== SET B: FOR 8"
CKV$B		EQU	CKV8		;<== SET B: FOR 8"
DEV$B		EQU	FDISK8+1	;<== SET B: FOR 8" UNIT 1
	ENDIF ;FD$USE AND (USE$8 AND NOT USE$5)
	IF FD$USE AND (NOT USE$8 AND USE$5)
ALV$A		EQU	ALV5		;<== SET A: FOR 5"          
CKV$A		EQU	CKV5		;<== SET A: FOR 5"          
DEV$A		EQU	FDISK5+0	;<== SET A: FOR 5" UNIT 0   

ALV$B		EQU	ALV5		;<== SET B: FOR 5"
CKV$B		EQU	CKV5		;<== SET B: FOR 5"
DEV$B		EQU	FDISK5+1	;<== SET B: FOR 5" UNIT 1
	ENDIF ;FD$USE AND (NOT USE$8 AND USE$5)

; -------- HARD DRIVE LOGICAL UNITS

	IF HD$USE AND (NOT FD$USE)
; HARD DISK ON A: & B:
ALV$A		EQU	(HD$SIZE0+3)/4	;<== SET A: FOR HARD DISK
CKV$A		EQU	CKVHD		;<== SET A: FOR HARD DISK
DEV$A		EQU	HDISK+0 	;<== SET A: FOR HARD DISK UNIT 0
HDLU$0		EQU	'A'-'A'		;<== LOGICAL HARD DISK 0 IS CP/M A:

ALV$B		EQU	(HD$SIZE1+3)/4	;<== SET B: FOR HARD DISK          
CKV$B		EQU	CKVHD		;<== SET B: FOR HARD DISK          
DEV$B		EQU	HDISK+1		;<== SET B: FOR HARD DISK UNIT 0   
HDLU$1		EQU	'B'-'A'		;<== LOGICAL HARD DISK 1 IS CP/M B:
	ENDIF ;HD$USE AND NOT FD$USE
	IF HD$USE AND FD$USE AND NOT DRV$ABCD
; HARD DISK ON C: & D:
ALV$C		EQU	(HD$SIZE0+3)/4	;<== SET C: FOR HARD DISK          
CKV$C		EQU	CKVHD		;<== SET C: FOR HARD DISK          
DEV$C		EQU	HDISK+0 	;<== SET C: FOR HARD DISK UNIT 0   
HDLU$0		EQU	'C'-'A'		;<== LOGICAL HARD DISK 0 IS CP/M C:

ALV$D		EQU	(HD$SIZE1+3)/4	;<== SET D: FOR HARD DISK          
CKV$D		EQU	CKVHD		;<== SET D: FOR HARD DISK          
DEV$D		EQU	HDISK+1		;<== SET D: FOR HARD DISK UNIT 0   
HDLU$1		EQU	'D'-'A'		;<== LOGICAL HARD DISK 0 IS CP/M D:
	ENDIF ;HD$USE AND NOT DRV$ABCD
	IF HD$USE AND FD$USE AND DRV$ABCD
; HARD DISK ON E: & F:
ALV$E		EQU	(HD$SIZE0+3)/4	;<== SET E: FOR HARD DISK
CKV$E		EQU	CKVHD		;<== SET E: FOR HARD DISK
DEV$E		EQU	HDISK+0 	;<== SET E: FOR HARD DISK UNIT 0
HDLU$0		EQU	'E'-'A'		;<== LOGICAL HARD DISK 0 IS CP/M E:

ALV$F		EQU	(HD$SIZE1+3)/4	;<== SET F: FOR HARD DISK
CKV$F		EQU	CKVHD		;<== SET F: FOR HARD DISK   
DEV$F		EQU	HDISK+1		;<== SET F: FOR HARD DISK UNIT 0
HDLU$1		EQU	'F'-'A'		;<== LOGICAL HARD DISK 0 IS CP/M F:
	ENDIF ;HD$USE AND FD$USE AND DRV$ABCD

; -------- CREATE EMPTY ALLOCATION VECTORS

	IF HD$USE AND (NOT FD$USE)
ALV$C		EQU	0		;<== SET C: FOR UNUSED
CKV$C		EQU	0		;<== SET C: FOR UNUSED
DEV$C		EQU	0		;<== SET C: FOR UNUSED

ALV$D		EQU	0		;<== SET D: FOR UNUSED
CKV$D		EQU	0		;<== SET D: FOR UNUSED
DEV$D		EQU	0		;<== SET D: FOR UNUSED
	ENDIF ;HD$USE AND (NOT FD$USE)

	IF NOT DRV$ABCD
ALV$E		EQU	0		;<== SET E: FOR UNUSED
CKV$E		EQU	0		;<== SET E: FOR UNUSED
DEV$E		EQU	0		;<== SET E: FOR UNUSED

ALV$F		EQU	0		;<== SET F: FOR UNUSED
CKV$F		EQU	0		;<== SET F: FOR UNUSED
DEV$F		EQU	0		;<== SET F: FOR UNUSED
	ENDIF ; NOT DRV$ABCD

ALV$G		EQU	0		;<== SET G: FOR UNUSED
CKV$G		EQU	0		;<== SET G: FOR UNUSED
DEV$G		EQU	0		;<== SET G: FOR UNUSED

ALV$H		EQU	0		;<== SET H: FOR UNUSED
CKV$H		EQU	0		;<== SET H: FOR UNUSED
DEV$H		EQU	0		;<== SET H: FOR UNUSED

ALV$I		EQU	0		;<== SET I: FOR UNUSED
CKV$I		EQU	0		;<== SET I: FOR UNUSED
DEV$I		EQU	0		;<== SET I: FOR UNUSED

ALV$J		EQU	0		;<== SET J: FOR UNUSED
CKV$J		EQU	0		;<== SET J: FOR UNUSED
DEV$J		EQU	0		;<== SET J: FOR UNUSED

ALV$K		EQU	0		;<== SET K: FOR UNUSED
CKV$K		EQU	0		;<== SET K: FOR UNUSED
DEV$K		EQU	0		;<== SET K: FOR UNUSED

ALV$L		EQU	0		;<== SET L: FOR UNUSED
CKV$L		EQU	0		;<== SET L: FOR UNUSED
DEV$L		EQU	0		;<== SET L: FOR UNUSED

ALV$M		EQU	0		;<== SET M: FOR UNUSED
CKV$M		EQU	0		;<== SET M: FOR UNUSED
DEV$M		EQU	0		;<== SET M: FOR UNUSED

ALV$N		EQU	0		;<== SET N: FOR UNUSED
CKV$N		EQU	0		;<== SET N: FOR UNUSED
DEV$N		EQU	0		;<== SET N: FOR UNUSED

ALV$O		EQU	0		;<== SET O: FOR UNUSED
CKV$O		EQU	0		;<== SET O: FOR UNUSED
DEV$O		EQU	0		;<== SET O: FOR UNUSED

ALV$P		EQU	0		;<== SET P: FOR UNUSED
CKV$P		EQU	0		;<== SET P: FOR UNUSED
DEV$P		EQU	0		;<== SET P: FOR UNUSED

	IF ISIO2
BASE		EQU	00H			;BASE OF PORTS
SER1DATA	EQU	BASE + 2	;SIO PORT A - DATA PORT
SER1STAT	EQU	BASE + 3	;SIO PORT A - STATUS PORT
SER1CTL		EQU	BASE + 3	;SIO PORT A - CTRL PORT
SER2DATA	EQU	BASE + 4	;SIO PORT B - DATA PORT
SER2STAT	EQU	BASE + 5	;SIO PORT B - STATUS PORT
SER2CTL		EQU	BASE + 5	;SIO PORT B - CTRL PORT
IECTL		EQU	BASE + 8	;SIO INTERRUPTS CTRL PORT
TxRDY		EQU	01H			;TRANSMIT BUFFER READY
RxRDY		EQU	02H			;RxREADY
	ENDIF ;ISIO2

	IF CSS1
BASE		EQU	05CH		; Port A
SER1DATA	equ	BASE + 0	;Console data
SER1STAT	equ	BASE+1		;Console status
SER1MODE	equ	BASE+2		;Console mode registers
SER1CTRL	equ	BASE+3		;Console command register
TxRDY		equ	  01h		;channel a Tx ready bit
RxRDY		equ	  02h		;channel a Rx ready bit
;Programable baud rate equates
STOP1		equ	06E00h		;8N1 x16
STOP2		equ	0EE00h		;8N2 x16
CTL2651		equ	27h			;Ctrl reg initialization value
;Console Port 2651 baud rates
;(The high byte of these words gets written first)
B110		equ	STOP2 or 72h	;110 baud (2 stop bits)
B150		equ	STOP1 or 74h	;150 baud
B300		equ	STOP1 or 75h	;300 baud
B600		equ	STOP1 or 76h	;600 baud
B1200		equ	STOP1 or 77h	;1200 baud
B2400		equ	STOP1 or 7Ah	;2400 baud
B4800		equ	STOP1 or 7Ch	;4800 baud
B9600		equ	STOP1 or 7Eh	;9600 baud
B192		equ	STOP1 or 7Fh	;19200 baud
PBAUD		EQU	B9600			;Console baud rate.
	ENDIF ;CSS1

; VARIOUS CONFIGURATION EQUATES FOR THE LIST  DEVICE -- MODIFY AS NEEDED
; SET ONLY ONE OF THE FOLLOWING EQUATES "TRUE" TO SELECT THE CPM LIST 
; DEVICE IF YOURE IO DEVICE IS NOT LISTED HERE THEN YOU MUST MODIFY THE 
; IO DRIVERS FOR YOUR IO DEVICE.
LST			EQU	FALSE	;<== SET TRUE FOR LIST DEVICE
LPST		EQU	00H		;<== LIST DEVICE STATUS PORT
LPDATA		EQU	00H		;<== LIST DEVICE DATA PORT
LPTxRDY		EQU	1h		;<== LPR TRANSMITTER READY (TxRDY)
LPRxRDY		EQU	2h		;<== LPR RECIEVER READY (RxRDY)

;
; VARIOUS CONFIGURATION EQUATES FOR THE PUNCH READER DEVICE - MODIFY AS NEEDED
; SET ONLY ONE OF THE FOLLOWING EQUATES "TRUE" TO SELECT THE CPM READER/PUNCH 
; DEVICE IF YOURE IO DEVICE IS NOT LISTED HERE THEN YOU MUST MODIFY THE 
; IO DRIVERS FOR YOURE IO DEVICE

RDRPUN		EQU	FALSE	;<== SET TRUE FOR READER/PUNCH ON RPDATA PORT
RPST		EQU	00H		;<== READER/PUNCH STATUS PORT
RPDATA		EQU	00H		;<== READER/PUNCH DATA PORT
RPTXR		EQU	1h		;<== READER/PUNCH TRANSMITTER READY (TxRDY)
RPRXR		EQU	2h		;<== READER/PUNCH RECIEVER READY (RxRDY)

; IF YOU HAVE A FRONT PANEL SET THE FOLLOWING EQUATE TO TRUE.
; THEN FIND THE CONDITIONAL ASSEMBLY THAT IS CONTROLLED BY THIS EQUATE.
; MAKE IT DO WHATEVER YOU WANT.

FRONTP		EQU	TRUE		;CPA FRONT PANEL EQUATE

;******************************************************************************
;  PARAMATERS BELOW THIS POINT SHOULD REQUIRE NO MODS
; 
;******************************************************************************

OMNIDATA 	EQU	0A0H		;<== DATA PORT FOR OMNI CONTROLLER
OMNISTAT 	EQU	OMNIDATA+1	;STATUS PORT FOR OMNI
OMNI$IN		EQU	01H		;OMNI HAS DATA TO SEND
OMNI$OUT 	EQU	80H		;OMNI CAN NOT ACCEPT ANOTHER BYTE NOW

	IF (NDISKS+99)/104
ASMDPH		EQU	FALSE		;>4 DRIVES: SAVE SPACE BY MAKING DPH AFTER BOOT
	ENDIF
	IF NOT (NDISKS+99)/104
ASMDPH		EQU	TRUE		;1-4 DRIVES: ASSEMBLE IN DPH
	ENDIF


;********************************************************
;	ASCII CHARACTER EQUATES				*
;********************************************************

LF			EQU	0AH		;LINE FEED
CR			EQU	0DH		;CARRIAGE RETURN
BEL			EQU	07H		;CONSOLE BELL


;********************************************************
;	COMMAND CODES FOR OMNI CONTROLLER V1.3				*
;********************************************************

OC$BOOT		EQU	0		;BOOT SYSTEM
OC$SWRT		EQU	1		;WRITE SYSTEM (INVERSE OF BOOT)
OC$MODE		EQU	2		;DMA/IO MODE
OC$FMTF		EQU	3		;FORMAT FLOPPY TRACK
OC$DLDS		EQU	4		;DEFINE LOGICAL DEVICE SET
OC$GLDS		EQU	5		;GET LOGICAL DEVICE SET
OC$FWRT		EQU	6      	;FORCE WRITE OF MODIFIED BUFFERS
OC$RSBP		EQU	7		;RESET BOOT PHANTOM
OC$SKEW		EQU	8		;SET NON-STANDARD SKEW FACTOR
OC$UNIT		EQU	9		;SELECT (LOGICAL) UNIT
OC$TRAK		EQU	10		;SELECT TRACK
OC$RECD		EQU	11		;SELECT (LOGICAL) RECORD
OC$DADR		EQU	12		;SET DMA ADDRESS
OC$READ		EQU	13		;READ
OC$WRIT		EQU	14		;WRITE
OC$HEAD		EQU	15		;SET HEAD (RESERVED FOR FUTURE USE)
OC$MOVM		EQU	16		;MOVE BLOCK OF MEMORY WITH DMA
OC$GDPB		EQU	17		;GET DPB (GET CP/M DPB FROM OMNI)
OC$DFMD		EQU	18		;DEFINE MEMORY DISK
OC$SSEK		EQU	19		;NON-IMPYED SEEK (NOT USED IN BIOS)
OC$TIOW		EQU	20		;DEBUG WRITES TO OMNI
OC$TIOR		EQU	21		;DEBUG READS FROM OMNI
OC$GENS		EQU	22		;GET GENERAL STATUS
OC$EXTS		EQU	23		;GET EXTENDED STATUS
OC$SRTY		EQU	24		;SET COUNTERS FOR (FLOPPY DISK) RETRY LOGIC
OC$DPBX		EQU	25		;GET EXTENDED DPB (CP/M 3.0)
OC$GBPB		EQU	26		;GET MS-DOS "BIOS PARAMETER BLOCK"
OC$GMCS		EQU	27		;GET MS-DOS "MEDIA CHANGE STATUS"
OC$SFDP		EQU	28		;SET FLOPPY DISK PARAMETERS
OC$PREA		EQU	29		;PHYSICAL SECTOR READ
OC$PWRI		EQU	30		;PHYSICAL SECTOR WRITE
OC$HDPR		EQU	31		;HARD DISK PARMS (#HDS, PCOMP, STP R, CTLR TYP)
OC$HDTB		EQU	32		;HARD DISK TABLES--DEV SEL, PHYS OFFSET, OS TBL
OC$FDIE		EQU	33		;Ignore Floppy Disk Errors & Mark Buffer Valid
OC$SIHD		EQU	34		;Set Individual HD Parameters
OC$GIHD		EQU	35		;Get Individual HD Parameters
OC$SFPB		EQU	36		;SET FLOPPY DPB AND PARAMETERS
OC$GFPB		EQU	37		;GET FLOPPY DPB AND PARAMETERS
OC$DRID		EQU	38		;READ I.D. INFO TO EXTENDED STATUS
OC$SIND		EQU	39		;SET INDIVIDUAL STEP RATES
OC$STPI		EQU	40		;SET TRACK DENSITY STATUS (TPI)
OC$GTPI		EQU	41		;INVERSE OF ABOVE
OC$GVER		EQU	42		;RETURN VERSION NUMBER
OC$GTAG		EQU	43		;RETURN BUFFER TAGS TO HOST
OC$INIT		EQU	255		;Re-Initialize Omnidisk Controller

;	ALL OTHER EQUATES (do not change)

IOBYTE		EQU	3				;INTEL I/O BYTE
DEFIOBYTE	EQU	00$00H			;00 (A:) FOR CDISK, 00 FOR IOBYTE
TPA			EQU	100H			;START OF TRANSIENT PGM AREA

LENBSTRAP	EQU	80H				;LENGTH RESERVED FOR BOOTSTRAP
BSORG		EQU	CCP-LENBSTRAP	;BOOTSTRAP ORGIN AS ASSEMBLED
								;NOTE: BOOTSTRAP IS LOADED INTO
								;      AND RUNS AT LOCATION 0000
BSTRAP		EQU	BSORG			;BOOTSTRAP LOAD ADDRESS

VALID		EQU	80H				;RAMDPB VALID
TPI96		EQU	20H				;96TPI DRIVE
DSTEP		EQU	10H				;DOUBLE STEP
DSIDE		EQU	04H				;DOUBLE SIDED

	ORG		BSORG
	LXI		H,TPA
	SPHL					;Stack grows down
	PUSH	H
	PUSH	H

	IF QUAD$DENS AND (NOT USE$8) AND USE$5
;	Set TPI flag
	LXI		H,STPI96-BSORG
	MVI		C,4
	CALL	SDAT-BSORG
	POP		H				;<HL>=STATUS BUFFER
	CALL	GDAT-BSORG		;Get data => STATUS BUFFER
	ORA		A				;Test status, <A> should be zero
	JNZ		BERR-BSORG		;Error HLT
;	Set RAMDPB
	LXI		H,SFPB-BSORG
	MVI		C,LENSFPB
	CALL	SDAT-BSORG
	POP		H				;<HL>=STATUS BUFFER
	CALL	GDAT-BSORG		;Get data => STATUS BUFFER
	ORA		A				;Test status, <A> should be zero
	JNZ		BERR-BSORG		;Error HLT
	ENDIF ;QUAD$DENS

;	Boot
	LXI		H,(BSLIST-BSORG)+(128-LENBSTRAP)
	MVI		C,5
	CALL	SDAT-BSORG
	LXI		H,BSTRAP		;BOOT ADDRESS
	CALL	GDAT-BSORG

;	Test status
	ORA		A				;Test status, <A> should be zero
	JZ		CBOOT			;IF GOOD STATUS ENTER COLD BOOT ENTRY IN BIOS

;	Boot error
BERR:
	IF FRONTP
	CMA						;IMSAI LEDS INVERTED
	OUT		0FFH			;LET FRONT PANEL SHOW ERROR
	ENDIF ;FRONTP
	HLT						;ELSE...DIE

;	Get data
GDAT:
	IN		OMNISTAT
	RRC						;Rotate right to test bit 0
	JNC		GDAT-BSORG		;IF DATA NOT READY
	ANI		40H				;(HAS OC$GENS BEEN ACCEPTED)
	IN		OMNIDATA		;TAKE A BYTE OF THE SYSTEM -OR- GENERAL STATUS
	RZ						;IF WE HAVE JUST READ GENERAL STAT
	MOV		M,A				;Store byte
	INX		H				;Bump <HL>
	JMP		GDAT-BSORG

;	Send command block
SDAT:
	IN		OMNISTAT
	RLC
	JC		SDAT-BSORG		;IF RECEIVER FULL
	MOV		A,M				;NEXT BYTE TO SEND
	OUT		OMNIDATA
	INX		H
	DCR		C
	JNZ		SDAT-BSORG	;IF MORE COMMAND LIST TO SEND
	RET

	IF QUAD$DENS AND (NOT USE$8) AND USE$5
STPI96:
	DB		OC$STPI			;Command: Set TPI flags
	DB		0				;P1: Unit (A:)
	DB		TPI96			;P2: [1]Flags
	DB		OC$GENS			;Command: Get GENSTAT
SFPB:
	DB		OC$SFPB			;Command: Set RAMDPB
	DB		0				;P1: Unit (A:)
	DB		VALID+TPI96		;P2: [1]Flags
	DB		0AH				;P3: [2]FDRELPOS
	DB		00H				;P4: [3]SECTOR I.D. OFFSET, SIDE 0
	DB		00H				;P5: [4]SECTOR I.D. OFFSET, SIDE 1
	DB		00H				;P6: [5]SIDE I.D. OFFSET, SIDE 0
	DB		00H				;P7: [6]SIDE I.D. OFFSET, SIDE 1
	DB		00H				;P8: [7]SKEW
	DB		15				;P9: [8]LEN DPB
;	RAMDPB					;Length=15
	DW		36				;SPT
	DB		04				;BLOCK SHIFT
	DB		15				;BSHIFTM-1
	DB		01				;EXM-1
	DW		343				;DISK SIZE-1
	DW		127				;DIRECTORY MAX-1
	DB		192				;ALV0
	DB		00				;ALB1
	DW		32				;CKS
	DW		4				;OFFSET
	DB		OC$GENS			;Command: Get GENSTAT
LENSFPB		EQU	$-SFPB
	ENDIF

	IF	($-BSORG)/(LENBSTRAP-5)
 EQU $-BSORG ;LENGTH OF BOOTSTRAP MAXIMUM IS LENBSTRAP-5 ...	SEE LISTING
	ENDIF

	ORG		(BSORG+LENBSTRAP)-5
BSLIST:
	DB	OC$UNIT,0			;SET DRIVE 0 (A:)
	DB	OC$BOOT				;BOOT
	DB	(BOOTLEN+127)/128	;BOOT LENGTH
	DB	OC$GENS				;GET GENERAL STATUS

;********************************************************
;							*
;	START OF BIOS FUNCTIONAL CODE			*
;							*
;********************************************************

	ORG		BIOS		;ORIGIN OF BIOS
;
;	Please do NOT try to rearrange the following jump vector.
;	CP/M calls the various subroutines by jump vector offset.

;
	JMP	CBOOT		;COLD START
WBOOTE:
	JMP	WBOOT		;WARM START
	JMP	IOCONST		;CONSOLE STATUS
	JMP	IOCONIN		;CONSOLE CHAR IN
	JMP	IOCONOUT	;CONSOLE CHAR OUT
	JMP	IOLIST		;LIST CHAR OUT
	JMP	IOPUNCH		;PUNCH CHAR OUT
	JMP	IOREADER	;READER CHAR OUT
	JMP	HOME		;MOVE HEAD TO HOME POSITION
	JMP	SELDSK		;SELECT DISK
	JMP	SETTRK		;SET TRK #
	JMP	SETSEC		;SET SECT #
	JMP	SETDMA		;SET DMA ADDR
	JMP	READ		;READ DISK
	JMP	WRITE		;WRITE DISK
	JMP	IOLISTST	;RETURN LIST STATUS
	JMP	SECTRAN		;SECT TRANSLATE

;The following are my extensions; Mainly for the hell of it.
;unfortunatly it won't fit in a 64k system with 5 drives.
;	JMP	GTIOB		;17 - GET PRESENT IO BYTE 
;	JMP	STIOB		;18 - SET IOBYTE
;	JMP	CLOCK		;19 - MY CLOCK ROUTINE
;
;**************** END OF CPM JUMP TABLE *****************

; *******************************************************
; *							*
; * The following byte determines if an initial command *
; * is to be given to CP/M on warm boot or cold boots.  *
; * The value of the byte is used to give the command   *
; * to CP/M.						*
; * 							*
; * 0 = Never give command.				*
; *	1 = Give command on cold boots only		*
; *	2 = Give the command on warm boots only		*
; *	3 = give the command on warm and cold boot	*
; *							*
; *******************************************************

AUTOFLG:	DB	0

; *******************************************************
; *	NOTE: CWFLAG indicates cold boot or warm boot    	*
; *	DO NOT CHANGE FROM DEFAULT VALUE ZERO		*
; *	0 = Cold boot [Default]		*
; *	1 = Warm Boot				*
; *******************************************************

CWFLAG:		DB	0		;COLD/WARM BOOT FLAG

;
; ************ EXTENSIONS TO STANDARD BIOS ******************
;GTIOB:	LDA	IOBYTE
;	RET
;
;STIOB:	MOV	A,C		;I FOLLOWED D. CORTESI EXAMPLE
;	STA	IOBYTE		;FOR HIS BIOS CALLS 18 & 19
;	RET
;
; ******************************************************
; This function read the clock on the SS-1 board 
; Note: I will have to lower base address of 64k to 62k
; to include this mess.
;*******************************************************
;zbase	equ	0c0h		;Base port
;
;CLOCK:		RET			;NULL ROUTINE FOR NOW.
;
;
;
;********************************************************
;	ACCESS PHYSICAL DEVICE DEPENDING ON CONTENTS	*
;	OF IOBYTE. INITIALIZED BY "IOINITIO" CODE.	*
;							*
;	PLEASE NOTE THE ONE-BYTE ADDRESSES USED BY	*
;	DISPATCH.  THIS SPACE SAVING METHOD SHOULD	*
;	NOT MAKE A PROBLEM, BUT IF IT DOES CONSIDER	*
;	PUTTING THE LONGEST I/O ROUTINE LAST.  OR	*
;	YOU COULD INSTALL A JMP TO A DISTANT ACCESS	*
;	ROUTINE.  IT WILL HELP IF THE DISPATCH		*
;	CALLS (PLUS THE 5 DB'S) ARE PLACED JUST		*
;	BEFORE THE REFERENCED ACCESS SUBROUTINES.	*
;********************************************************

;	CONSOLE STATUS - CON:
UD$CONST 	EQU	FALSE		;<== USE DISPATCH FOR IOCONST IF TRUE
							;(IF FALSE, THEN CRTSTAT IS ASSUMED)
	IF UD$CONST
IOCONST:
	CALL	DISPATCH
	DB	1		;USE IOBYTE BITS 1-0
	DB	CRTSTAT-$	;00 - TTY: (CRT STATUS)
	DB	CRTSTAT-$	;01 - CRT:	"
	DB	CRTSTAT-$	;10 - BAT:	"
	DB	CRTSTAT-$	;11 - UC1:	"
	ENDIF

;	CONSOLE IN - CON:
UD$CONIN 	EQU	FALSE		;<== USE DISPATCH FOR IOCONIN IF TRUE
							;(IF FALSE, THEN CRTIN IS ASSUMED)
	IF UD$CONIN
IOCONIN:
	CALL	DISPATCH
	DB	1		;USE IOBYTE BITS 1-0
	DB	CRTIN-$		;00 - TTY: (CRT INPUT)
	DB	CRTIN-$		;01 - CRT:	"
	DB	CRTIN-$		;10 - BAT:	"
	DB	CRTIN-$		;11 - UC1:	"
	ENDIF

;	CONSOLE OUT - CON:
UD$CONOUT	EQU	FALSE		;<== USE DISPATCH FOR IOCONOUT IF TRUE
							;(IF FALSE, THEN CRTOUT IS ASSUMED)
	IF UD$CONOUT
IOCONOUT:
	CALL	DISPATCH
	DB	1		;USE IOBYTE BITS 1-0
	DB	CRTOUT-$	;00 - TTY: (CRT OUTPUT)
	DB	CRTOUT-$	;01 - CRT:	"
	DB	CRTOUT-$	;10 - BAT:	"
	DB	CRTOUT-$	;11 - UC1:	"
	ENDIF

;	LIST OUT - LST:
UD$LIST		EQU	FALSE			;<== USE DISPATCH FOR IOLIST IF TRUE
							;(IF FALSE, THEN LPTOUT IS ASSUMED)
	IF UD$LIST
IOLIST:
	CALL DISPATCH
	DB	3		;USE IOBYTE BITS 7-6
	DB	CRTOUT-$	;00 - TTY: (CRT OUTPUT)
	DB	CRTOUT-$	;01 - CRT:	"
	DB	LPTOUT-$	;10 - LPT: (LINE PRINTER OUTPUT)
	DB	CRTOUT-$	;11 - UL1: (CRTSOLE OUTPUT)

;	LIST STATUS -LST:

IOLISTST:
	CALL DISPATCH
	DB	3		;USE IOBYTE BITS 7-6
	DB	CRTSTAT-$	;00 - TTY: (CRT OUTPUT)
	DB	CRTSTAT-$	;01 - CRT:	"
	DB	LPTSTAT-$	;10 - LPT: (LINE PRINTER OUTPUT)
	DB	CRTSTAT-$	;11 - UL1: (CRTSOLE OUTPUT)
	ENDIF

;	PUNCH OUT - PUN:
UD$PUNCH	EQU	FALSE		;<== USE DISPATCH FOR IOPUNCH IF TRUE
							;(IF FALSE, THEN PUNOUT IS ASSUMED)
	IF UD$PUNCH
IOPUNCH:
	CALL	DISPATCH
	DB	5		;USE IOBYTE BITS 5-4
	DB 	CRTOUT-$	;00 - TTY: (CRTSOLE OUTPUT)
	DB	PUNOUT-$	;01 - PTP: (HIGH SPEED PUNCH OUTPUT)
	DB	CRTOUT-$	;10 - UP1: (CRTSOLE OUTPUT)
	DB	CRTOUT-$	;11 - UP2:	"
	ENDIF

;	READER IN - RDR:
UD$READER	EQU	FALSE		;<== USE DISPATCH FOR IOREADER IF TRUE
							;(IF FALSE, THEN RDRIN IS ASSUMED)
	IF UD$READER
IOREADER:
	CALL	DISPATCH
	DB	7		;USE IOBYTE BITS 3-2
	DB	CRTIN-$		;00 - TTY: (CRT INPUT)
	DB	RDRIN-$		;01 - PTR: (HIGH SPEED READER INPUT)
	DB	CRTIN-$		;10 - UR1: (CRT INPUT)
	DB	CRTIN-$		;11 - UR2:	"
	ENDIF

;********************************************************
;	LIST CHARACTER IN C				*
;********************************************************

	IF NOT UD$LIST
IOLIST:					;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

LPTOUT:
	IF LST
	CALL	LPTSTAT		;GET PRINTER STATUS
	JZ		LPTOUT		;LOOP IF NOT READY

	IF ISIO2
	MOV		A,C			;NO
	OUT		SER2DATA	;SEND IT
	ENDIF ;ISIO2

	ENDIF ;LST
	RET					;BYE

;********************************************************
;	RETURN LIST STATUS (FF IF READY, ELSE 0)	*
;********************************************************

	IF NOT UD$LIST
IOLISTST:				;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

LPTSTAT:
	IF LST
	IF ISIO2
	IN		SER2STAT	;GET SIO PORT B STATUS
	ANI		TxRDY		;IS IT BUSY
	ENDIF ;ISIO2
	ENDIF ;LST

	IF NOT LST
 	XRA		A			;...THEN ALLWAYS READY
	ENDIF ;NOT LST

	DCR		A			;<A> AS ADVERTISED
	RET					;BYE

;********************************************************
;	CRT STATUS RETURNED IN A.			*
;							*
;	<A>=00	KEYBOARD CHARACTER NOT READY		*
;	<A>=FF  KEYBOARD CHARACTER READY		*
;********************************************************

	IF NOT UD$CONST
IOCONST:				;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

CRTSTAT:
	IN		SER1STAT	;STATUS PORT
	ANI		RxRDY		;TEST RxRDY
	RZ					;IF NOT READY
	MVI		A,0FFH		;ELSE...RETURN <FF>
	RET					;BYE

;********************************************************
;	CRTIN RETURNS KEYBOARD CHARACTER IN <A>		*
;********************************************************

	IF NOT UD$CONIN
IOCONIN:				;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

CRTIN:
    CALL	CRTSTAT
	JZ		CRTIN		;GET RxRDY
    IN		SER1DATA    ;GET CHAR
	ANI	7FH				;STRIP PARITY
	RET					;BYE

;********************************************************
;	CRT SENDS THE CHARACTER IN <C> TO OUTPUT
;********************************************************

	IF NOT UD$CONOUT
IOCONOUT:				;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

CRTOUT:
    IN  	SER1STAT    ;GET STATUS
	ANI		TxRDY		;TxRDY?
	JZ		CRTOUT		;REPEAT, NOT READY
	MOV		A,C			;CHAR TO ACCUM
    OUT 	SER1DATA    ;CHAR TO PORT
	RET

;********************************************************
;	PUNCH CHARACTER IN REGISTER <C>			*
;********************************************************

	IF NOT UD$PUNCH
IOPUNCH:				;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

PUNOUT:
	IF RDRPUN
	IN		RPST
	ANI		RPTXR
	JZ		PUNOUT		;IF RECIEVER NOT READY FOR NEXT BYTE
	MOV		A,C
	OUT		RPDATA		;DATA TO "PUNCH"
	ENDIF ;RDRPUN

;	NOTE: IF RDRPUN=FALSE WE USE RET FROM RDRIN

;********************************************************
;	READ CHARACTER INTO <A> FROM READER DEVICE	*
;********************************************************

	IF NOT UD$READER
IOREADER:				;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

RDRIN:
	IF RDRPUN
	IN		RPST
	ANI		RPRXR
	JZ		RDRIN		;IF NO DATA FROM "READER" AS YET
	IN		RPDATA		;ACCEPT BYTE FROM READER
	ENDIF ;RDRPUN
	IF NOT RDRPUN
	MVI		A,1AH		;NO READER? RETURN ^Z AS EOF INDICATION
	ENDIF ;NOT RDRPUN
	RET					;BYE

;********************************************************
;	DISPATCH TO ACCESS CONSOLE, PRINTER PUNCH, ETC	*
;							*
;	(FOR MAX RANGE ON ONE-BYTE ADDRESSES IT IS	*
;	 BEST TO LEAVE THIS ROUTINE AFTER THE END	*
;	 OF THE LAST CRT, PRINTER, PUNCH OR WHATEVER	*
;	 ACCESS SUBROUTINE.)				*
;********************************************************

IF UD$CONST OR UD$CONIN OR UD$CONOUT OR UD$LIST OR UD$PUNCH OR UD$READER
DISPATCH:
	XTHL			;SAVE CALLER'S <HL>, GET TABLE ADDR
	MOV		D,M		;SHIFT COUNT
	INX		H		;POINT TABLE
	LDA 	IOBYTE	;GET IO ASSIGNMENTS BYTE
DSHFT:
	RLC
	DCR		D
	JNZ		DSHFT	;SHIFT TO POSITION BITS
	RRC
	ANI		03H		;MASK BITS
	MOV		E,A		;D ALREADY CLEAR
	DAD		D		;INDEX INTO TABLE
	MOV		E,M		;FETCH PROPER ADDRESS BYTE
	DAD		D		;ADD BACK THE "-$" OR DISPATCH ADDRESS TO <HL>
	XTHL			;PUT DISPATCH ADDRESS, RESTORE CALLER'S <HL>
	RET				;GO TO ROUTINE
ENDIF

;********************************************************
;	WBOOT LOADS CP/M FROM THE SYSTEM TRACKS		*
;********************************************************

;	WE NEED TO RELOAD CCP BECAUSE SOME TRANSISANT PROGRAMS
;	USE CCP'S SPACE AS PART THIER SCRATCH STORAGE.  BUT WE ALSO
;	NEED TO BE CAREFULL BECAUSE SELF-RELOCATING PROGRAMS LIKE
;	DDT/SID, DESPOOL AND XSUB RUN JUST BELOW CCP.  DESPOOL
;	AND XSUB NEED TO SURVIVE A WARM BOOT.
;
;	WE TELL THE OMNIDISK CONTROLLER THAT WE	WANT TO LOAD THE
;	BOOTSTRAP PLUS ALL OF CCP ROUNDED UP TO A LOGICAL SECTOR.
;	THE FIRST 80H BYTES OF WHAT WE READ IS OUR BOOTSTRAP WHICH
;	WE MUST NOT LOAD ON TOP OF A SELF-RELOCATING PROGRAM.
;
;	ALL WOULD BE EASY IF ERROR RECOVERY WERE NOT REQUIRED.
;
;	WE DO OUR NORMAL READ WITH GET-GENERAL-STATUS.  THE FIRST
;	BYTE RETURNED IS EITHER THE FIRST BYTE OF THE BOOTSTRAP OR THE
;	GENERAL STATUS ANNOUNCING THE FAILURE.  IF FAILURE, WE LOOP
;	BACK AND TRY AGAIN, ELSE WE KNOW THAT AT LEAST THE REST OF
;	THE FIRST SECTOR IS WAITING TO BE DELIVERED.  NEXT WE READ AND
;	TRASH THE OTHER 3FH BYTES OF THE BOOTSTRAP AND THEN CALL GETDAT
;	TO RESTORE CCP.  WHEN GETDAT RETURNS, WE CHECK GENERAL STATUS.
;	IF AN ERROR IS INDICATED WE GO BACK AND RETRY THE OPERATION.
;
;	THERE ARE NO MESSAGES IN THE RETRY LOOP.  THERE IS NO WAY TO
;	ABORT ITS OPERATION SHORT OF HITTING RESET.
;
WBOOT0:
	STA		CDISK		;(FROM BIOS ERROR RECOVERY) SET FOR "A:" DISK
WBOOT:					;MAIN ENTRY TO THIS SECTION
	LXI		SP,TPA		;USE SPACE BELOW TPA FOR STACK
	CALL	CMDLIST
	DB	5					;LENGTH OF LIST
	DB	OC$UNIT,0			;SELECT A: DISK
	DB	OC$BOOT
	DB	(BDOS-BSORG+127)/128;NUMBER OF (LOGICAL) SECTORS TO LOAD
	DB	OC$GENS				;GENERAL STATUS REQUEST FOR READ END
	CALL	INCHAR		;THIS IS EITHER 1ST OF BOOTSTRAP OR GENSTAT
	IN		OMNISTAT
	ORA		A			;WHAT DID INCHAR JUST DELIVER?
	JP		WBOOT		;IF WE GOT GENSTAT THEN ERROR.  GO RETRY.
	MVI		C,LENBSTRAP-1
WBOOT1:
	CALL	INCHAR		;READ AND TRASH BOOTSTRAP PART OF 1ST SECTOR
	DCR		C
	JNZ		WBOOT1		;IF MORE BOOTSTRAP TO TRASH
	LXI		H,CCP
	CALL	GETDAT
	ORA		A			;GENERAL STATUS
	JNZ		WBOOT		;IF ERROR RELOADING CCP WE GO TRY AGAIN
	MVI		A,1
	STA		CWFLAG		;Set warm boot flag
;	...					;FALL INTO GOCPM

;********************************************************
;	SET PARAMETERS AND GO TO CP/M			* 		
;********************************************************

GOCPM:
	MVI		A,(JMP)
	STA		0			;JMP TO WBOOT
	LXI		H,WBOOTE	;WBOOT ENTRY POINT
	SHLD	1			;JUMP ADDR AT 0

	STA		5			;JMP TO BDOS
	LXI		H,BDOS		;BDOS ENTRY POINT
	SHLD	6			;JUMP ADDR AT 5

	LXI		B,80H		;** SETUP DEFAULT
	CALL	SETDMA		;** DMA ADDRESS

	IF FRONTP
	MVI		A,255
	OUT		0FFH		;0 FRONT PANEL
	ENDIF

;	CLEAN UP AND GO TO CCP

	LDA		CDISK		;CURRENT DISK #
	MOV		C,A			;SEND TO CCP
	EI					;ENABLE INTERRUPTS

	LDA		CWFLAG		;IS COLD OR WARM BOOT?
	ANA		A			;SET FLAGS. NOTE:DO NOT DO ANYTHING TO CHANGE
						; FLAGS FROM HERE TO COLDBT:
	LDA		AUTOFLG		;DO WE HAVE AN AUTOBOOT?
	JZ		COLDBT		;If Cold Boot
	RAR					;Else warm boot tests
COLDBT:
	RAR
	JC		CCP			;DO AUTOBOOT
	JMP		CCP+3		;JUST GO TO CCP

;********************************************************
; 	ROUTINES START HERE				*
;********************************************************
;	DISK I/O DRIVERS. STORE	THE PARAMETERS		*
;	AWAY FOR THE READ AND WRITE SUBROUTINES		*
;********************************************************

;********************************************************
;	SELECT DISK GIVEN BY <C>			*
;********************************************************

SELDSK:
	LXI		H,0			;USED FOR <H>=0 AND IF SELECT ERROR
	MOV		A,C
	CPI		NDISKS		;MUST BE BETWEEN 0 AND NDISKS-1
	RNC					;IF INVALID DISK NUMBER

;	COMPUTE PROPER DISK PARAMETER HEADER ADDR

	CALL	ONELIST
	DB	OC$UNIT			;OMNI COMMAND: SELECT LOGICAL UNIT
	MOV		A,C			;UNIT ADDRESS...
	CALL	SENDCMD		;...TO OMNI
	MOV		L,C			;<HL> = UNIT NUMBER (A:=0, B:=1,,, P:=0FH)
	DAD		H			;*2
	DAD		H			;*4
	DAD		H			;*8
	DAD		H			;*16 (SIZE OF EACH HEADER)
	LXI		B,DPHBASE
	DAD		B			;<HL> = DPH ADDRESS
	MOV		A,E
	RAR
	RC					;IF DRIVE WAS LOGGED
;
;	DRIVE NEVER LOGGED -- CALL DRIVE SELECT
;
	SHLD	DPHADRS		;SAVE DPH ADDRESS IN CASE WE NEED TO RETRY
	CALL	SRETA		;SET RETRY ADDRESS FOR CKERR
	LXI		H,$-$
DPHADRS EQU	$-2
	PUSH	H			;DPH ADDRESS
	CALL	SELDRV		;DO THE GETDPB STUFF
	POP		H			;DPH ADDRESS
	JMP		CKERR		;CHECK ERROR, GIVE ERROR MSG ETC

;********************************************************
;	HOME THE HEAD TO TRACK 0			*
;********************************************************

HOME:
	LXI		B,0
;	...					;FALL INTO SETTRK

;********************************************************
;	SET TRACK GIVEN IN <BC>				*
;********************************************************

SETTRK:
	CALL	ONELIST
	DB	OC$TRAK			;OMNI COMMAND: SELECT TRACK (CYLINDER)
	CALL	CMDINC		;LOW BITS OF TRACK NUMBER TO OMNI
	MOV		A,B
	JMP		SENDCMD		;HIGH BITS OF TRACK NUMBER TO OMNI

;********************************************************
;	SET SECTOR (RECORD NUMBER) GIVEN BY <C>		*
;********************************************************

SETSEC:
	CALL	ONELIST
	DB	OC$RECD			;OMNI COMMAND: SELECT SECTOR NUMBER
CMDINC:
	MOV		A,C			;THE SECTOR NUMBER
	JMP		SENDCMD

;********************************************************
;	SECTOR LOGICAL TO PHYSICAL TRANSLATION		*
;							*
;	TRANSLATE DELAYED UNTIL I/O DONE IN OMNIDISK	*
;	RETURN WITH SECTOR FROM BC IN HL				*
;********************************************************

SECTRAN:
	MOV	L,C
	MOV	H,B
	RET

;********************************************************
;	SET DMA GIVEN BY <BC> FOR READ/WRITE BUFF	*
;********************************************************

SETDMA:	
	IF NOT DMA
	MOV		L,C			;LOW ADDR BYTE
	MOV		H,B			;HIGH ADDR BYTE
	SHLD	DMAADR		;DMA ADDR
	RET
	ENDIF ;NOT DMA

	IF DMA
	MOV		L,C			;LOW ADDR BYTE
	MOV		H,B			;HIGH ADDR BYTE
	SHLD	DMAADR		;DMA ADDR
	CALL	CMDLIST
	DB	4				;LENGTH OF LIST
	DB	OC$DADR			;OMNI COMMAND: SET DMA ADDRESS
DMAADR
	DW	0				;DMA ADDRESS LOW AND HIGH
	DB	DMAEXT			;DMA ADDRESS EXTENDED
	RET
	ENDIF ;DMA

;********************************************************
;	READ A LOGICAL SECTOR				*
;********************************************************

READ:
	CALL	SRETA		;SET RETRY ADDRESS (USED IF OMNI I/O ERROR)
	CALL	CMDLIST
	DB	2				;LENGTH OF LIST
	DB	OC$READ,OC$GENS	;OMNI COMMANDS: READ AND GET GENERAL STATUS

	IF NOT DMA
	LXI		H,$-$
DMAADR	EQU	$-2
	CALL	GETDAT		;GET THE DATA, RETURN GENERAL STATUS
	JMP		CKERR
	ENDIF ;NOT DMA

	IF DMA
	JMP		WRITE2		;DMA: WAIT FOR AND THEN CHECK GENERAL STATUS
	ENDIF ;DMA

;********************************************************
;	WRITE A LOGICAL SECTOR				*
;********************************************************
;	WRITE THE SELECTED CP/M SECTOR
;		AT ENTRY C = 0 - FOR NORMAL SECTOR WRITE
;			     1 - WRITE DIRECTORY SECTOR
;			     2 - WRITE SECTOR OF A NEW DATA BLOCK
;

WRITE:
	MOV		A,C
	STA		WRITEA		;SAVE WRITE MODIFIER
	CALL	SRETA		;SET RETRY ADDRESS (USED IF OMNI I/O ERROR)
	CALL	CMDLIST
	DB	2				;LENGTH OF LIST
	DB	OC$WRIT			;OMNI COMMAND: WRITE TO DISK
WRITEA	DB	$-$			;WRITE MODIFIER TO OMNI

	IF NOT DMA 
	CALL	INCHAR		;GET GEN STATUS BEFORE WRITE DATA XFER
	ORA		A
	JNZ		CKERR		;IF ERROR IN READ-BEFORE-WRITE
	MVI		C,128		;SIZE OF SECTOR
	LHLD	DMAADR
WRITE1:
	IN		OMNISTAT
	ADD		A
	JC		WRITE1		;IF NOT READY FOR NEXT BYTE
	MOV		A,M
	OUT		OMNIDATA	;WRITE DATA TO OMNI
	INX		H
	DCR		C
	JNZ		WRITE1		;IF MORE DATA TO SEND
	XRA		A			;FAKE GOOD STATUS FOR CKERR
	ENDIF ;NOT DMA

	IF DMA
WRITE2:
	CALL	INCHAR		;GET GENERAL STATUS AFTER DATA XFER
	ENDIF ;DMA

;	...	FALL INTO CKERR

;********************************************************
;	SUBROUTINE FOR UNEXPECTED DRIVE ERRORS		*
;********************************************************

CKERR:
	ORA		A
	RZ					;IF NO ERROR
	CALL	ONELIST
	DB	OC$EXTS			;OMNI COMMAND: GET EXTENDED STATUS
;						(THIS IS THE ONLY WAY TO ZERO GENSTAT)
	LXI		H,DERRM1
	CALL	OUTM		;OUT MESSAGE = "DISK I/O ERROR -"
	MVI		B,9			;LENGTH OF EXTENDED STATUS LIST
CKERR1:
	MVI	C,' '
	CALL	IOCONOUT
	CALL	INCHAR		;GET EXTENDED STATUS BYTE FROM OMNI
	CALL	HEXOUT		;SEND TO CONSOLE
	DCR		B
	JNZ		CKERR1		;IF NO MORE EXTENDED STATUS
	CALL	OUTM		;OUT MESSAGE = "^C ABORT etc..."
	CALL	IOCONIN		;WAIT FOR RESPONSE FROM USER
	LXI		H,0			;FOR "IGNORE" EXIT WHEN USED FROM SELDSK
	CPI		0DH
	RZ					;IF cr THEN RTN TO BDOS WITH <A> NON-ZERO
	SUI		'C'-40H
	JZ		WBOOT0		;IF ^C WE ABORT CHANGING LOGGED DISK TO "A:"
	JMP		$-$			;ELSE...RETRY FAILED OPERATION
RETRY$ADDRESS	EQU	$-2

DERRM1
	DB		CR,LF
	DB		'DISK I/O ERROR -',0
DERRM2:
	DB		CR,LF
	DB		'^C ABORT, cr IGNORE, ELSE RETRY',0

;
; OUTPUT NULL TERMINATED MESSAGE
; <HL> = LOCATION OF STRING
;
OUTM:
	MOV		A,M
	INX		H
	ORA		A
	RZ					;IF AT END OF MESSAGE
	CALL	ACONOUT		;SEND TO CONSOLE
	JMP		OUTM		;REPEAT UNTIL DONE

HEXOUT:
	PUSH	PSW
	RAR 
	RAR 
	RAR
	RAR					;POSITION HIGH ORDER NIBBLE...
	CALL	HEXOUT1		;...SEND TO CONSOLE
	POP		PSW			;NOW LOW NIBBLE
HEXOUT1:
	ANI		0FH			;ISOLATE NIBBLE
	SUI		10
	JM		HEXOUT2		;IF CONVERTING 0-9
	ADI		7			;ELSE CONVERTING A-F
HEXOUT2:
	ADI		10+'0'		;NIBBLE NOW CONVERTED TO ASCII
ACONOUT:
	MOV		C,A
	JMP		IOCONOUT	;SEND TO CONSOLE AND RETURN TO OUR CALLER

;********************************************************
;	SET RETRY ADDRESS FOR OMNI I/O ERRORS		*
;********************************************************

sreta:
	xthl				;SWAP TOP OF STACK <-> HL
	shld	RETRY$ADDRESS
	xthl				;RESTORE TOP OF STACK
	ret

;********************************************************
;	SELECT A NEW DRIVE				*
;********************************************************
;
;	NOTE USE OF TRACK 4 IN GETDPB.  ONE MIGHT THINK THAT TRACK
;	TWO (DIRECTORY) WOULD BE BETTER.  TRACK 4 WAS SELECTED
;	BECAUSE (1) WE DO NOT WANT THE DIRECTORY TRACK BECAUSE
;	IT IS THE MOST LIKELY TO BE ZAPPED BY A SYSTEM PROBLEM,
;	(2) WE DO NOT WANT ANY SYSTEM TRACKS BECAUSE THEY MIGHT
;	BE FORMATTED AT SOME DENSITY OTHER THAN THE REST OF THE
;	DISK AND (3) THE SYSTEM TAKES 3 TRACKS ON SOME 5" FLOPPIES.

SELDRV:
	LXI		D,10		;DPH OFFSET TO DPB
	DAD		D
	MOV		E,M			;LOW DPB
	INX		H
	MOV		H,M			;HIGH DBP
	MOV		L,E			;<HL> = DPB ADDRESS
	CALL	CMDLIST
	DB	5				;LENGTH OF LIST
	DB	OC$TRAK			;OMNI COMMAND: SELECT TRACK (SEEK)
	DW	4				;GO TO TRACK 4 FOR GETDPB FUNCTION
	DB	OC$GDPB			;OMNI COMMAND: GET DPB
	DB	OC$GENS			;OMNI COMMAND: GET GENERAL STATUS
;				    	 (USED TO END GETDAT LOOP)
;	... FALL INTO GETDAT

;********************************************************
;	SUBROUTINE FOR BLOCK READ			*
;							*
;	NOTE:	THIS SUBROUTINE READS DATA UNTIL	*
;		THE OMNI CONTROLLER ACCEPTS THE		*
;		GENERAL STATUS COMMAND			*
;********************************************************

GETDAT:
	IN		OMNISTAT
	RRC					;Rotate right to test bit 0
	JNC		GETDAT		;IF NOTHING TO GET FROM OMNI
	ANI		40H			;(WHAT DO WE HAVE HERE: DATA -OR- GEN STATUS?)
	IN		OMNIDATA	;TAKE IT, WHATEVER IT IS
	RZ					;IF IT IS GENERAL STATUS, THEN RETURN
	MOV		M,A			;ELSE...PUT INTO BUFFER
	INX		H
	JMP		GETDAT		;KEEP ON KEEPING ON

;********************************************************
;	SUBROUTINE TO SEND CONSTANT BYTE TO OMNIDISK	*
;********************************************************

ONELIST:
	XTHL
	MOV		A,M
	INX		H
	XTHL
;	...	FALL INTO SENDCMD

;********************************************************
;	SUBROUTINE TO SEND COMMAND TO DISK CONTROLLER	*
;********************************************************

SENDCMD:
	PUSH	PSW			;BYTE TO SEND TO OMNI
SENDCMD1:
	IN		OMNISTAT
	RLC					;Rotate left to test bit 7
	JC		SENDCMD1	;IF OMNI NOT READY TO TAKE BYTE
	POP		PSW
	OUT		OMNIDATA	;SEND BYTE TO OMNI
	RET

;****************************************************************
;	SUBROUTINE TO ACCEPT ONE BYTE FROM DISK CONTROLLER	*
;****************************************************************

INCHAR:
	IN		OMNISTAT
	RRC					;Rotate right to test bit 0
	JNC		INCHAR		;IF OMNI HAS NOT YET SENT REPLY
	IN		OMNIDATA	;ACCEPT REPLY
	RET

;********************************************************
;	SUBROUTINE TO ISSUE COMMAND LIST		*
;********************************************************

CMDLIST:
	XTHL
	MOV		C,M			;FETCH LENGTH OF LIST
	INX		H
CMDLIST1:
	MOV		A,M			;NEXT BYTE TO SEND
	INX		H
	CALL	SENDCMD		;BYTE TO CONTROLLER
	DCR		C
	JNZ		CMDLIST1	;IF MORE COMMANDS TO SEND
	XTHL
	RET

;********************************************************
;	DISK PARAMETER HEADER TABLES			*
;********************************************************
;
;	PLEASE NOTE SEVERAL THING ABOUT THIS TABLE:
;
;	(1) THE "IF (NDISKS+99)/100" LOOKS STRANGE, BUT HAD TO BE
;	    MORE COMPLEX THAN "NDISKS/nn" BECAUSE OF AN UNDOCUMENTED
;	    FEATURE (THIS SOFTWARE WRITER CALLS IT A BUG) THAT
;	    MAKES "IF EXP" ACT AS IT WERE WRITTEN "IF EXP AND 1".
;
;	(2) THE "DW DEV$x" IN PLACE OF THE SKEW TABLE ADDRESS
;	    IS CLEARLY NOT SKEW TABLE ADDRESS.  IT IS USED BY
;	    BY THE LU-CHANGING UTILITY AND PERHAPS SOMEDAY BY
;	    COLD START WITHIN THE BIOS.

DPHBASE:
	IF (NDISKS+99)/100		;DPH FOR DRIVE 0 ( A: )
	DW	DEV$A,0,0,0,DIRBUF
	DW	TDPB$A,TCKV$A,TALV$A
	ENDIF

	IF (NDISKS+99)/101		;DPH FOR DRIVE 1 ( B: )
	DW	DEV$B,0,0,0,DIRBUF
	DW	TDPB$B,TCKV$B,TALV$B
	ENDIF

	IF (NDISKS+99)/102		;DPH FOR DRIVE 2 ( C: )
	DW	DEV$C,0,0,0,DIRBUF
	DW	TDPB$C,TCKV$C,TALV$C
	ENDIF

	IF (NDISKS+99)/103		;DPH FOR DRIVE 3 ( D: )
	DW	DEV$D,0,0,0,DIRBUF
	DW	TDPB$D,TCKV$D,TALV$D
	ENDIF

	IF (NDISKS+99)/104		;DPH FOR DRIVE 4 ( E: )
	DW	DEV$E,0,0,0,DIRBUF
	DW	TDPB$E,TCKV$E,TALV$E
	ENDIF

	IF (NDISKS+99)/105		;DPH FOR DRIVE 5 ( F: )
	DW	DEV$F,0,0,0,DIRBUF
	DW	TDPB$F,TCKV$F,TALV$F
	ENDIF

	IF (NDISKS+99)/106		;DPH FOR DRIVE 6 ( G: )
	DW	DEV$G,0,0,0,DIRBUF
	DW	TDPB$G,TCKV$G,TALV$G
	ENDIF

	IF (NDISKS+99)/107		;DPH FOR DRIVE 7 ( H: )
	DW	DEV$H,0,0,0,DIRBUF
	DW	TDPB$H,TCKV$H,TALV$H
	ENDIF

	IF (NDISKS+99)/108		;DPH FOR DRIVE 8 ( I: )
	DW	DEV$I,0,0,0,DIRBUF
	DW	TDPB$I,TCKV$I,TALV$I
	ENDIF

	IF (NDISKS+99)/109		;DPH FOR DRIVE 9 ( J: )
	DW	DEV$J,0,0,0,DIRBUF
	DW	TDPB$J,TCKV$J,TALV$J
	ENDIF

	IF (NDISKS+99)/110		;DPH FOR DRIVE 10 ( K: )
	DW	DEV$K,0,0,0,DIRBUF
	DW	TDPB$K,TCKV$K,TALV$K
	ENDIF

	IF (NDISKS+99)/111		;DPH FOR DRIVE 11 ( L: )
	DW	DEV$L,0,0,0,DIRBUF
	DW	TDPB$L,TCKV$L,TALV$L
	ENDIF

	IF (NDISKS+99)/112		;DPH FOR DRIVE 12 ( M: )
	DW	DEV$M,0,0,0,DIRBUF
	DW	TDPB$M,TCKV$M,TALV$M
	ENDIF

	IF (NDISKS+99)/113		;DPH FOR DRIVE 13 ( N: )
	DW	DEV$N,0,0,0,DIRBUF
	DW	TDPB$N,TCKV$N,TALV$N
	ENDIF

	IF (NDISKS+99)/114		;DPH FOR DRIVE 14 ( O: )
	DW	DEV$O,0,0,0,DIRBUF
	DW	TDPB$O,TCKV$O,TALV$O
	ENDIF

	IF (NDISKS+99)/115		;DPH FOR DRIVE 15 ( P: )
	DW	DEV$P,0,0,0,DIRBUF
	DW	TDPB$P,TCKV$P,TALV$P
	ENDIF
DPHEND:

;--------------------------------------------------------
;-	THE FOLLOWING CODE RUNS RIGHT AFTER THE SYSTEM	-
;-	IS LOADED.  NO CODE IN THIS AREA CAN BE USED	-
;-	AGAIN BECAUSE VARIOUS BUFFERS ARE ALLOCATED	-
;-	PAST THIS POINT.				-
;--------------------------------------------------------

DSORG:				;ORG FOR UN-INIT "DS" BUFFERS

	IF NOT ASMDPH	;ie IF WE ARE USING THE DPH BUILDER
	ORG	DPHBASE		;THEN ASSEMBLE THE COLD START
	ENDIF			;CODE ON TOP OF THE DPH AREA

;********************************************************
;	SIGN ON MESSAGE DURING COLD BOOT		*
;********************************************************

SIGNON:
	DB	CR,LF
	DB	'Version for '
	IF	FD$USE AND (USE$8 AND NOT USE$5)
	DB	'A:,B:-> 8" FLOPPY'
	ENDIF ;NOT HD$USE AND (USE$8 AND NOT USE$5)
	IF	FD$USE AND (NOT USE$8 AND USE$5)
	DB	'A:,B:-> 5" FLOPPY'
	ENDIF ;FD$USE AND (NOT USE$8 AND USE$5)
	IF	FD$USE AND BOOT$8 AND DRV$ABCD
	DB	'A:,B:-> 8" FLOPPY, C:,D:-> 5" FLOPPY'
	ENDIF ;FD$USE AND BOOT$8 AND DRV$ABCD
	IF	FD$USE AND (NOT BOOT$8) AND DRV$ABCD
	DB	'A:,B:-> 5" FLOPPY, C:,D:-> 8" FLOPPY'
	ENDIF ;FD$USE AND (NOT BOOT$8) AND DRV$ABCD
	IF	HD$USE AND NOT FD$USE
	DB	'A:,B:-> HARD DISK'
	ENDIF ;HD$USE AND NOT FD$USE
	IF	HD$USE AND FD$USE AND NOT DRV$ABCD
	DB	'C:,D:-> HARD DISK'
	ENDIF ;HD$USE AND FD$USE AND NOT DRV$ABCD
	IF	HD$USE AND FD$USE AND DRV$ABCD
	DB	'E:,F:-> HARD DISK'
	ENDIF ;HD$USE AND FD$USE AND DRV$ABCD
	DB	CR,LF

	DB	'Fulcrum Omnidisk (c)1987 '

;	For MOVCPM: XXK CP/M X.X
	DB	'0'+MSIZE/10		;CP/M MEMORY SIZE
	DB	'0'+(MSIZE MOD 10)
	DB	'K CP/M '			;CP/M VERSION NUMBER
	DB 	CPMREV/10+'0'
	DB 	'.'
	DB	(CPMREV MOD 10)+'0'
	DB	CR,LF

	IF FD$USE AND QUAD$DENS
	DB	'QUAD-DENSITY '
	ENDIF ;QUAD$DENSITY
	IF DMA
	DB	'DMA '
	ENDIF ;DMA
	DB	'BIOS rev '
	DB	REVNUM/10+'0','.'	;BIOS REVISION NUMBER
	DB	REVNUM MOD 10+'0'
	DB	CR,LF
	DB	0

;********************************************************
;	COLD BOOT INITIALIZES VARIABLES IN PAGE ZERO,	*
;	SETS THE OMNIDISK CONTROLLER FOR THE DESIRED	*
;	DEVICE SET, DOES WHATEVER HARDWARE INIT MAY BE	*
;	REQUIRED AND PRINTS THE SIGN-ON MESSAGE.	*
;							*
; REMEMBER, THIS AREA IS OVERLAYED WITH VARIOUS BUFFERS	*
;							*
;********************************************************

CBOOT:
	LXI		SP,TPA			;MEM BELOW TPA FOR STACK
	LXI		H,DEFIOBYTE		;<L>=DEFAULT IO BYTE
	SHLD	IOBYTE			;IOBYTE IS LOC 3, CDISK IS LOC 4
	XRA		A				;<A>=0
	STA		CWFLAG			;CLEAR COLD BOOT FLAG

;
;	UNDEFINE ALL LOGICAL-TO-PHYSICAL MAPPING WITHIN CONTROLLER.
;
	IF ((NDISKS+99)/111) XOR 1	;ie IF NDISKS .LE. 11
	LXI		H,CB2
CB1:
	CALL	CMDLIST
	DB	3					;LENGTH OF LIST
	DB	OC$DLDS				;OMNI COMMAND: DEFINE LOGICAL DEVICE SET
CB2:
	DB	0FH					;LOGICAL UNIT...
	DB	0					;...SET TO UNDEFINED
	DCR		M				;NEXT LOGICAL UNIT <M>=CB2
	JP		CB1				;IF WE NEED TO ZAP MORE UNITS
	ENDIF ;((NDISKS+99)/111) XOR 1
;
	CALL	CMDLIST
	DB	CBLEND-$-1			;LENGTH OF LIST
	DB	OC$MODE				;OMNI COMMAND: SET DMA OR NON-DMA MODE

	IF NOT DMA
	DB	DMAPRI				;NOTE TO USERS WHERE DMA KILLS YOUR SYSTEM:
							;BIOS DOES NOT CAUSE ANY DMA
	ENDIF ;NOT DMA			;UNLESS MEMORY DISK IS USED.

	IF DMA
	DB	DMAPRI+80H			;BIOS USES DMA FOR READ/WRITE
	ENDIF ;DMA
;
;	DEFINE FLOPPY DISK PHYSICAL PARAMETERS
;
	IF FD$USE
	DB	OC$SFDP				;OMNI COMMAND: SET FLOPPY DISK PARAMETERS
	DB	WDELAY,LDELAY		;DELAYS BEFORE WRITE & UNLOADING HEADS
	DB	STEP8,STEP5			;FLOPPY STEP RATE
	DB	LOAD8,LOAD5			;FLOPPY HEAD LOAD TIME
	DB	SETL8,SETL5			;HEAD SETTLE TIME (AFTER FD SEEK)
	ENDIF ;FD$USE
;
;	DEFINE LOGICAL-TO-PHYSICAL MAPPINGS USED BY CURRENT SYSTEM
;	
	IF (NDISKS+99)/100		;DRIVE 0 ( A: )
	DB	OC$DLDS,00H,DEV$A	;DEFINE A:
	ENDIF
	IF (NDISKS+99)/101		;DRIVE 1 ( B: )
	DB	OC$DLDS,01H,DEV$B	;DEFINE B:
	ENDIF
	IF (NDISKS+99)/102		;DRIVE 2 ( C: )
	DB	OC$DLDS,02H,DEV$C	;DEFINE C:
	ENDIF
	IF (NDISKS+99)/103		;DRIVE 3 ( D: )
	DB	OC$DLDS,03H,DEV$D	;DEFINE D:
	ENDIF
	IF (NDISKS+99)/104		;DRIVE 4 ( E: )
	DB	OC$DLDS,04H,DEV$E	;DEFINE E:
	ENDIF
	IF (NDISKS+99)/105		;DRIVE 5 ( F: )
	DB	OC$DLDS,05H,DEV$F	;DEFINE F:
	ENDIF
	IF (NDISKS+99)/106		;DRIVE 6 ( G: )
	DB	OC$DLDS,06H,DEV$G	;DEFINE G:
	ENDIF
	IF (NDISKS+99)/107		;DRIVE 7 ( H: )
	DB	OC$DLDS,07H,DEV$H	;DEFINE H:
	ENDIF
	IF (NDISKS+99)/108		;DRIVE 8 ( I: )
	DB	OC$DLDS,08H,DEV$I	;DEFINE I:
	ENDIF
	IF (NDISKS+99)/109		;DRIVE 9 ( J: )
	DB	OC$DLDS,09H,DEV$J	;DEFINE J:
	ENDIF
	IF (NDISKS+99)/110		;DRIVE 10 ( K: )
	DB	OC$DLDS,0AH,DEV$K	;DEFINE K:
	ENDIF

	IF (NDISKS+99)/111		;DRIVES 11-15( L:-P: )
	DB	OC$DLDS,0BH,DEV$L	;DEFINE L:
	DB	OC$DLDS,0CH,DEV$M	;DEFINE M:
	DB	OC$DLDS,0DH,DEV$N	;DEFINE N:
	DB	OC$DLDS,0EH,DEV$O	;DEFINE O:
	DB	OC$DLDS,0FH,DEV$P	;DEFINE P:
	ENDIF
;
	IF (FD$USE AND BOOT$8) AND SKEW$3 AND USE$8
;CHANGE DEVICE 0 FOR A SKEW OF 3 FOR MORROW FORMAT SSDD 1024
	DB	OC$SKEW				;OMNI COMMAND: SET SKEW
	DB	00H					;LOGICAL DEVICE 0 - A:
	DB	43H					;SECTOR CODE LENGTH 3
; + DOUBLE DENSITY (40H)
	DB	08					;NUMBER OF SECTORS
	DB	03					;DESIRED SKEW FACTOR
;DITTO DEVICE 1
	DB	OC$SKEW				;;OMNI COMMAND: SET SKEW
	DB	01H					;LOGICAL DEVICE 1 - B:
	DB	43H					;SECTOR CODE LENGTH 3
; + DOUBLE DENSITY (40H)
	DB	08					;NUMBER OF SECTORS
	DB	03					;DESIRED SKEW FACTOR
	ENDIF ;(FD$USE AND BOOT$8) AND SKEW$3 AND USE$8
	IF (FD$USE AND NOT BOOT$8) AND SKEW$3 AND USE$8
;CHANGE DEVICE 0 FOR A SKEW OF 3 FOR MORROW FORMAT SSDD 1024
	DB	OC$SKEW				;OMNI COMMAND: SET SKEW
	DB	02H					;LOGICAL DEVICE 2 - C:
	DB	43H					;SECTOR CODE LENGTH 3
; + DOUBLE DENSITY (40H)
	DB	08					;NUMBER OF SECTORS
	DB	03					;DESIRED SKEW FACTOR
;DITTO DEVICE 1
	DB	OC$SKEW				;;OMNI COMMAND: SET SKEW
	DB	03H					;LOGICAL DEVICE 3 - D:
	DB	43H					;SECTOR CODE LENGTH 3
; + DOUBLE DENSITY (40H)
	DB	08					;NUMBER OF SECTORS
	DB	03					;DESIRED SKEW FACTOR
	ENDIF ;(FD$USE AND NOT BOOT$8) AND SKEW$3 AND USE$8
;
;	DEFINE HARD DISK STUFF IF WE ARE USING IT
;
	IF HD$USE
	DB	OC$HDPR				;OMNI COMMAND: SET HARD DISK PARAMETERS
	DB	HD$NHDS				;HARD DISK NUMBER OF HEADS
	DB	HD$PCMP				;PRE-COMP (FOR WRITES ABOVE *PHYSICAL* CYL)
	DB	HD$STEP				;HARD DISK STEP RATE (0=COMPILED SEEK)
	DB	HD$CTLR				;CONTROLLER TYPE
	ENDIF ;HD$USE
;
;	DEFINE HARD DISK TABLES FOR FIRST HARD DISK
;
	IF HD$USE0
	DB	OC$HDTB				;OMNI COMMAND: SET HARD DISK TABLE
	DB	HDLU$0				;LOGICAL UNIT FOR FIRST LOGICAL HARD DISK
	DB	HD$SEL0				;PHYS HD SEL CODE (0, 8, 10H, 18H ONLY)
	DW	HD$BASE0			;PHYS TRK OFFSET OF FOLLOWING OS BLOCK
							;DO NOT CONFUSE WITH CP/M OFFSET IN DPB
	DB	15					;LENGTH OF FOLLOWING OS BLOCK (DPB FOR CP/M)
	DW	64					;LOGICAL SECTORS PER TRACK
	DB	5,31				;4K ALLOCATION SIZE
	DB	1					;>255 ALLOCATION UNITS (JUST OVER 1MEG)
	DW	HD$SIZE0*2-1		;MAX ALLOC UNIT NUMBER (2 ALLOC/TRACK)
	DW	511					;1024 DIRECTORY ENTRIES
	DW	00F0H				;8 ALLOCATION UNITS FOR DIRECTORY
	DW	0					;NO DIRECTORY CHECK VECTOR
	DW	2					;SPACE FOR 2 SYSTEM TRACKS
	ENDIF ;HD$USE0
;
; NOW THE SECOND LOGICAL HARD DISK
;
	IF HD$USE1
	DB	OC$HDTB				;OMNI COMMAND: SET HARD DISK TABLE
	DB	HDLU$1				;LOGICAL UNIT FOR SECOND LOGICAL HARD DISK
	DB	HD$SEL1				;PHYS HD SEL CODE (0, 8, 10H, 18H ONLY)
	DW	HD$BASE1			;PHYS TRK OFFSET OF FOLLOWING OS BLOCK
							;DO NOT CONFUSE WITH CP/M OFFSET IN DPB
	DB	15					;LENGTH OF FOLLOWING OS BLOCK (DPB FOR CP/M)
	DW	64					;LOGICAL SECTORS PER TRACK
	DB	5,31				;4K ALLOCATION SIZE
	DB	1					;>255 ALLOCATION UNITS (JUST OVER 1MEG)
	DW	HD$SIZE1*2-1		;MAX ALLOC UNIT NUMBER (2 ALLOC/TRACK)
	DW	511					;512 *****1024 DIRECTORY ENTRIES
	DW	00F0H				;4 *******8 ALLOCATION UNITS FOR DIRECTORY
	DW	0					;NO DIRECTORY CHECK VECTOR
	DW	2					;SPACE FOR 2 SYSTEM TRACKS
	ENDIF ;HD$USE1
;
; NOW THE THIRD LOGICAL HARD DISK
;
	IF HD$USE2
	DB	OC$HDTB				;OMNI COMMAND: SET HARD DISK TABLE
	DB	HDLU$2				;LOGICAL UNIT FOR THIRD LOGICAL HARD DISK
	DB	HD$SEL2				;PHYS HD SEL CODE (0, 8, 10H, 18H ONLY)
	DW	HD$BASE2			;PHYS TRK OFFSET OF FOLLOWING OS BLOCK
							;DO NOT CONFUSE WITH CP/M OFFSET IN DPB
	DB	15					;LENGTH OF FOLLOWING OS BLOCK (DPB FOR CP/M)
	DW	64					;LOGICAL SECTORS PER TRACK
	DB	5,31				;4K ALLOCATION SIZE
	DB	1					;>255 ALLOCATION UNITS (JUST OVER 1MEG)
	DW	HD$SIZE2*2-1		;MAX ALLOC UNIT NUMBER (2 ALLOC/TRACK)
	DW	511					;512 *****1024 DIRECTORY ENTRIES
	DW	00F0H				;4 *******8 ALLOCATION UNITS FOR DIRECTORY
	DW	0					;NO DIRECTORY CHECK VECTOR
	DW	2					;SPACE FOR 2 SYSTEM TRACKS
	ENDIF ;HD$USE2
;
; NOW THE FOURTH LOGICAL HARD DISK
;
	IF HD$USE3
	DB	OC$HDTB				;OMNI COMMAND: SET HARD DISK TABLE
	DB	HDLU$3				;LOGICAL UNIT FOR FOURTH LOGICAL HARD DISK
	DB	HD$SEL3				;PHYS HD SEL CODE (0, 8, 10H, 18H ONLY)
	DW	HD$BASE3			;PHYS TRK OFFSET OF FOLLOWING OS BLOCK
							;DO NOT CONFUSE WITH CP/M OFFSET IN DPB
	DB	15					;LENGTH OF FOLLOWING OS BLOCK (DPB FOR CP/M)
	DW	64					;LOGICAL SECTORS PER TRACK
	DB	5,31				;4K ALLOCATION SIZE
	DB	1					;>255 ALLOCATION UNITS (JUST OVER 1MEG)
	DW	HD$SIZE3*2-1		;MAX ALLOC UNIT NUMBER (2 ALLOC/TRACK)
	DW	511					;512 *****1024 DIRECTORY ENTRIES
	DW	00F0H				;4 *******8 ALLOCATION UNITS FOR DIRECTORY
	DW	0					;NO DIRECTORY CHECK VECTOR
	DW	2					;SPACE FOR 2 SYSTEM TRACKS
	ENDIF ;HD$USE3
;
;	DEFINE MEMORY DISK STUFF IF WE ARE USING IT
;
	IF MD$USE
	DB	OC$DFMD				;OMNI COMMAND: DEFINE MEMORY DISK
;
;	ADDRESSES OF MEMORY DISK AREAS
;
	DB	MD$B1,MD$B1+MD$S1 ;MEMORY DISK BASE AND LAST BLOCK+1 -- GROUP 1
	DB	MD$B2,MD$B2+MD$S2 ;MEMORY DISK BASE AND LAST BLOCK+1 -- GROUP 2
	DB	MD$B3,MD$B3+MD$S3 ;MEMORY DISK BASE AND LAST BLOCK+1 -- GROUP 3
	DB	MD$B4,MD$B4+MD$S4 ;MEMORY DISK BASE AND LAST BLOCK+1 -- GROUP 4
;
;	MEMORY DISK DPB
;
	DB	15					;LENGTH OF DPB
	DW	40H					;SPT	   8K BYTES PER "TRACK"
	DB	4,0FH				;BSH, BLM  2K ALLOCATION SIZE
	DB	MD$EXM				;EXM
	DW	MD$AL-1				;DSM       MAXIMUM ALLOCATION UNIT NUMBER
	DW	MD$FILES-1			;DRM	   MAXIMUM EXTENT NUMBER (DIRECTORY)
	DW	MD$AL01				;AL0, AL1  BITS FOR ALLOC UNITS IN DIRECTORY
	DW	0					;CKS	   NO CKECK VECTOR
	DW	MD$SCYL				;OFF	   8K/"CYL" GIVES SPACE FOR SYSTEM
;
;	FLAG, WHICH IF NON-ZERO, CAUSES MEM DISK INIT.
;
	DB 0 ;**DEBUG** DB	1	;INIT MEMORY DISK
;
;	THE MEMORY DISK INIT CALLED FOR HERE IS ONLY DONE ONCE
;	PER POWER-ON.  (ON POWER-ON THE OMNIDISK RESETS ITS MEMORY-
;	DISK-HAS-BEEN-INIT FLAG; WHEN REQUESTED TO INIT, AS IS DONE
;	HERE, IF THE FLAG IS SET THE INIT IS IGNORED ELSE THE INIT
;	IS DONE AND THE FLAG IS SET.)
;
;	IT IS DONE THIS WAY IN ORDER TO PRESERVE THE MEMORY DISK
;	WHEN RESET IS USED, BUT STILL PROVIDE AUTOMATIC OPERATION
;	ON POWER-ON.
;
;	SETTING THE ABOVE "DB" TO 80H OVERRIDES THE ONCE-PER-POWER-ON
;	SWITCH AND DOES THE INIT UNCONDITIONALY.  BUT WE DON'T WANT
;	TO DO THAT HERE.
;
;	YOU HAVE NOT SEEN CP/M PERFORM UNTIL THE A: DISK IS A MEMORY DISK.
;
	ENDIF ;MD$USE

CBLEND	EQU	$				;END OF LIST

;----------------------------------------
;Initialize the IMSAI SIO-2 ports A & B
;----------------------------------------
	IF ISIO2
    MVI		A,00H			;Zero
    OUT		SER1CTL			;SIO PORT A
    OUT		SER1CTL
    OUT		SER1CTL
	OUT		SER2CTL			;SIO PORT B
	OUT		SER2CTL
	OUT		SER2CTL
    MVI		A,40H			;RESET
    OUT		SER1CTL			;SIO PORT A
	OUT		SER2CTL			;SIO PORT B
    MVI		A,4EH			;8 BITS, 1 STOP, NO PARITY, /16
    OUT		SER1CTL			;SIO PORT A
	OUT		SER2CTL			;SIO PORT B
    MVI		A,37H			;RTS,DTR ASSERTED, RX-TX ENABLED
    OUT		SER1CTL			;SIO PORT A
	OUT		SER2CTL			;SIO PORT B
    IN		SER1DATA		;CLEAR POWER ON JUNK
	IN		SER2DATA
	ENDIF

;----------------------------------------
;Initialize the Compupro System Support-1
;----------------------------------------
	IF CSS1
	IN		SER1CTRL		;reset mode byte flipflop
;Set Console Stop bits, Parity, Baud rate factor
	MVI		A,PBAUD shr 8
	OUT		SER1MODE		;
;Set Console baud rate
	MVI		A,PBAUD and 0FFh
	OUT		SER1MODE		;
;Control reg initialization
	MVI		A,CTL2651		;Enable Tx, Rx, RTS=low, DTR=low
	OUT		SER1CTRL
	IN		SER1DATA		;CLEAR POWER ON JUNK
	ENDIF ;CSS1

;
;	ISSUE SIGN ON MESSAGE
;
	LXI		H,SIGNON
	CALL	OUTM
;
;	IF NDISKS > 4 THEN ASMDPH WILL BE FALSE AND THE DPH TABLE
;	AS ASSEMBLED SOME PAGES BACK IS OVERLAYED WITH THE SIGNON
;	MESSAGE AND OTHER COLD BOOT CODE.
;
;	IF NDISKS < 5 THEN THE SYSTEM SIZE (AS WRITTEN TO THE SYSTEM
;	TRACKS) IS SMALLER IF WE DON'T GET FANCY.  IN THIS CASE WE
;	SIMPLY DON'T OVERLAY THE DPH TABLE.
;
	IF ASMDPH				;** SIMPLE
	JMP		GOCPM			;** STUFF FOR
	ENDIF					;** SMALL SYSTEMS

ADPHX	EQU	($+6-DPHEND)/8000H	;NOTE: THE "+6" IS THE LENGTH OF 2 LXI'S
ADPHY	EQU	DPHEND-6-$
ADPHZ	EQU	(ADPHY-3)/8000H		;USED ONLY IF "NOT ASMDPH", SEE BELOW

	IF NOT ASMDPH			;ELSE...LET'S GET TRICKY AND REDUCE BOOT LENGTH
GENDPH:
	LXI		B,DPHGENT		;DPH GENERATOR TABLE
	LXI		H,DPHBASE		;WHERE GENERATED DPH GOES
	ENDIF

;******************************************************************************
;
;	THE FOLLOWING CONDITIONAL ASSEMBLY ASSURES THAT THE DPH GENERATOR
;	WILL NOT OVERLAY ITSELF AS IT RUNS.
;
;	WITH THE SIGNON MESSAGE AS RELEASED AND MPUBPORT=FALSE THIS
;	SECTION DOES NOTHING UNLESS NDISKS>14.  WITH MPUBPORT=TRUE
;	THIS SECTION DOES NOTHING UNLESS NDISKS>11.
;

	IF NOT ASMDPH AND ADPHX AND ADPHZ
	NOP
	NOP						;USE NOP'S IF NO ROOM TO ASSEMBLE JMP
	ENDIF

	IF NOT ASMDPH AND ADPHX AND NOT ADPHZ
	JMP		GDPH1			;USE JMP IF WE HAVE ROOM
	ENDIF

	IF NOT ASMDPH AND ADPHX
	ORG	DPHEND				;PUT FOLLOWING CODE WHERE IT WON'T GET ZAPPED
	ENDIF

;******************************************************************************

	IF NOT ASMDPH
GDPH1:
	LDAX	B
	INX		B
	ORA		A
	JM		GOCPM			;IF ALL DPH SLOTS ARE GENERATED
	LXI		D,8
	DAD		D				;<HL>=DPH PLACE FOR DIRBUF ADDRESS
	MVI		M,DIRBUF-DIRBUF/256*256
	INX		H
	MVI		M,DIRBUF/256
	INX		H
	MVI		E,15			;<DE>=LENGTH OF DPB -- NOTE: <D>=0
	CALL	GDPHSUB			;DPB ADDRESS TO DPH
	MOV		E,A				;<DE>=LENGTH OF CHECK VECTOR -- NOTE: <D>=0
	CALL	GDPHSUB			;CHECK VECTOR ADDRESS TO DPH
	LDAX	B	
	INX		B
	MOV		E,A				;LOW BITS OF ALLOCATION VECTOR LENGTH
	LDAX	B
	INX		B
	MOV		D,A				;<DE>=LENGTH OF ALLOCATION VECTOR
	CALL	GDPHSUB			;ALLOCATION VECTOR ADDRESS TO DPH
	JMP		GDPH1

GDPHSUB:
	PUSH	D
	LXI		D,DIRBUF+128	;WARNING: INSTRUCTION IS MODIFIED
GDPHSA:
	EQU	$-2
	MOV		M,E				;** TABLE
	INX		H				;** ADDRESS
	MOV		M,D				;** TO
	INX		H				;** DPH
	XTHL					;ENTRY <DE> TO <HL>
	XCHG					;ENTRY <DE> RESTORED, TBL ADRS TO <HL>
	DAD		D				;<HL>=NEXT TABLE ADDRESS...
	SHLD	GDPHSA			;...SAVE IN LXI INSTRUCTION
	POP		H				;RESTORE <HL> AS INCREMENTED
	RET
	ENDIF

DPHGENT:			;DPH GENERATOR TABLE

	IF NOT ASMDPH AND (NDISKS+99)/100	;FOR DRIVE 0 ( A: )
	DB	CKV$A
	DW	ALV$A
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/101	;FOR DRIVE 1 ( B: )
	DB	CKV$B
	DW	ALV$B
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/102	;FOR DRIVE 2 ( C: )
	DB	CKV$C
	DW	ALV$C
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/103	;FOR DRIVE 3 ( D: )
	DB	CKV$D
	DW	ALV$D
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/104	;FOR DRIVE 4 ( E: )
	DB	CKV$E
	DW	ALV$E
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/105	;FOR DRIVE 5 ( F: )
	DB	CKV$F
	DW	ALV$F
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/106	;FOR DRIVE 6 ( G: )
	DB	CKV$G
	DW	ALV$G
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/107	;FOR DRIVE 7 ( H: )
	DB	CKV$H
	DW	ALV$H
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/108	;FOR DRIVE 8 ( I: )
	DB	CKV$I
	DW	ALV$I
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/109	;FOR DRIVE 9 ( J: )
	DB	CKV$J
	DW	ALV$J
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/110	;FOR DRIVE 10 ( K: )
	DB	CKV$K
	DW	ALV$K
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/111	;FOR DRIVE 11 ( L: )
	DB	CKV$L
	DW	ALV$L
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/112	;FOR DRIVE 12 ( M: )
	DB	CKV$M
	DW	ALV$M
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/113	;FOR DRIVE 13 ( N: )
	DB	CKV$N
	DW	ALV$N
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/114	;FOR DRIVE 14 ( O: )
	DB	CKV$O
	DW	ALV$O
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/115	;FOR DRIVE 15 ( P: )
	DB	CKV$P
	DW	ALV$P
	ENDIF

	IF NOT ASMDPH
	DB	0FFH				;END OF DPHGENT LIST
	ENDIF

BOOTLEN	EQU	$-BSORG			;CP/M + CBIOS LEN TO LOAD FOR BOOTSTRAP

	IF	BOOTLEN/1A01H
 EQU; WARNING ... SYSTEM LONGER THAN 1A00H WILL NOT FIT ON SD DISKETTE
	ENDIF

CD$SPACE EQU (MSIZE*1024)-$ ;SPACE FOR ADDITIONAL CODE AT END OF BIOS

	IF	CD$SPACE / 8000H
CD$OVER	EQU	-CD$SPACE	;HOW MUCH YOU ARE OVER
 EQU;SEE LISTING FOR CODE SPACE REMAINING CONSIDERATIONS
	ENDIF

;--------------------------------------------------------
;-	END OF ONE-TIME EXECUTION CODE. 		-
;--------------------------------------------------------

	ORG	DSORG

;********************************************************
;	UN-INIT SCRATCH RAM AREA FOR BDOS USE		*
;********************************************************

DIRBUF:	DS	128					;DIRECTORY BUFFER

	IF (NDISKS+99)/100			;DRIVE 0 ( A: )
TDPB$A:	DS	15
TCKV$A:	DS	CKV$A
TALV$A:	DS	ALV$A
	ENDIF

	IF (NDISKS+99)/101			;DRIVE 1 ( B: )
TDPB$B:	DS	15
TCKV$B:	DS	CKV$B
TALV$B:	DS	ALV$B
	ENDIF

	IF (NDISKS+99)/102			;DRIVE 2 ( C: )
TDPB$C:	DS	15
TCKV$C:	DS	CKV$C
TALV$C:	DS	ALV$C
	ENDIF

	IF (NDISKS+99)/103			;DRIVE 3 ( D: )
TDPB$D:	DS	15
TCKV$D:	DS	CKV$D
TALV$D:	DS	ALV$D
	ENDIF

	IF (NDISKS+99)/104			;DRIVE 4 ( E: )
TDPB$E:	DS	15
TCKV$E:	DS	CKV$E
TALV$E:	DS	ALV$E
	ENDIF

	IF (NDISKS+99)/105			;DRIVE 5 ( F: )
TDPB$F:	DS	15
TCKV$F:	DS	CKV$F
TALV$F:	DS	ALV$F
	ENDIF

	IF (NDISKS+99)/106			;DRIVE 6 ( G: )
TDPB$G:	DS	15
TCKV$G:	DS	CKV$G
TALV$G:	DS	ALV$G
	ENDIF

	IF (NDISKS+99)/107			;DRIVE 7 ( H: )
TDPB$H:	DS	15
TCKV$H:	DS	CKV$H
TALV$H:	DS	ALV$H
	ENDIF

	IF (NDISKS+99)/108			;DRIVE 8 ( I: )
TDPB$I:	DS	15
TCKV$I:	DS	CKV$I
TALV$I:	DS	ALV$I
	ENDIF

	IF (NDISKS+99)/109			;DRIVE 9 ( J: )
TDPB$J:	DS	15
TCKV$J:	DS	CKV$J
TALV$J:	DS	ALV$J
	ENDIF

	IF (NDISKS+99)/110			;DRIVE 10 ( K: )
TDPB$K:	DS	15
TCKV$K:	DS	CKV$K
TALV$K:	DS	ALV$K
	ENDIF

	IF (NDISKS+99)/111			;DRIVE 11 ( L: )
TDPB$L:	DS	15
TCKV$L:	DS	CKV$L
TALV$L:	DS	ALV$L
	ENDIF

	IF (NDISKS+99)/112			;DRIVE 12 ( M: )
TDPB$M:	DS	15
TCKV$M:	DS	CKV$M
TALV$M:	DS	ALV$M
	ENDIF

	IF (NDISKS+99)/113			;DRIVE 13 ( N: )
TDPB$N:	DS	15
TCKV$N:	DS	CKV$N
TALV$N:	DS	ALV$N
	ENDIF

	IF (NDISKS+99)/114			;DRIVE 14 ( O: )
TDPB$O:	DS	15
TCKV$O:	DS	CKV$O
TALV$O:	DS	ALV$O
	ENDIF

	IF (NDISKS+99)/115			;DRIVE 15 ( P: )
TDPB$P:	DS	15
TCKV$P:	DS	CKV$P
TALV$P:	DS	ALV$P
	ENDIF

DS$SPACE EQU (MSIZE*1024)-$		;SPACE FOR ADDITIONAL UN-INIT MEM AT END OF BIOS

	IF	DS$SPACE / 8000H
DS$OVER	EQU	-DS$SPACE			;HOW MUCH YOU ARE OVER
 EQU;SEE LISTING FOR DS SPACE REMAINING CONSIDERATIONS
	ENDIF

	END
