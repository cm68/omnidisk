;TITLE	'+++ CP/M 2.2 BIOS FOR OMNI  29 DEC 84  TIME 1920 +++'
; DON'T FORGET TO CHANGE DATE IN "SIGNON" MESSAGE
;****************************************************************
;*								*
;*		   ****    ***    ***     ***			*
;*		   *   *    *    *   *   *   *			*
;*		   *   *    *    *   *   *			*
;*	  	   ****     *    *   *    ***			*
;*		   *   *    *    *   *       *			*
;*		   *   *    *    *   *   *   *			*
;*		   ****    ***    ***     ***			*
;*								*
;****************************************************************
;*								*
;*	PROPERTY OF:	FULCRUM COMPUTER PRODS			*
;*			451 ALLEN COURT				*
;ª			HEALSBURG¬ CALIFORNIÁ			*
;*					 USA			*
;*								*
;*			  (707) 433-0202			*
;*								*
;****************************************************************
;*								*
;*	BIOS VERSION 5.0:					*
;*								*
;*	FOR USE WITH THE FULCRUM AMAZING (TAH,			*
;*	TAH, TAH, TAAAAAH) OMNIDISK CONTROLLER			*
;*								*
;****************************************************************

;	REVISION HISTORY
;
;	WARM BOOT NO LONGER DIES IF A: DISK NOT READY
;	PROPER STATUS RETURNED FROM IOCONST
;	DPH GENERATOR USED IF NDISKS>4
;	PROPER RETRY IF ERROR DURING GETDPB
;	^C RESPONSE TO DISK ERROR MSG SETS A: DISK
;	SLOW$WRITE OPTION TO SAVE SPACE IN NON-DMA SYSTEMS
;	ADD RDRPUN CONDITIONAL ASM
;	ADD FD LOAD, STEP &C STUFF
;	ADD MULTIPLE-LOGICAL HARD DISK STUFF
;	ADD LEN BYTE BEFORE MEMORY DISK DPB
;	ADD CONDITIONAL ASSEMBLY FOR MANY HARD DISK TYPES
;	REWORK BYTE I/O DEVICES FOR MANY SPECIFICS
;	ADD VIOX CLOCK SET FROM MPUZ OPTION
;	USE [1FH] INSTED OF [CR,LF] IF USING VIOX
;	SAVE SPACE WITH CONDITIONAL ASSEMBLY AROUND "DISPATCH" FANOUT
;	FIX IN IOLISTST WITH SIO40B FOR STANDARD RESPONSE IN <A>
;	SAVE 3 BYTES IN SENDING DISK ERROR MESSAGE

;********************************************************
;	AS RELEASED, THIS ASM FILE IS SET UP FOR	*
;	ASSEMBLY WITH THE CP/M (tm) "ASM" ASSEMBLER.	*
;							*
;	ANY COMMENTED EQUATE STARTING WITH		*
;		;<== 'COMMENT LINE'			*
;	CAN BE CHANGED BY YOU, ALL OTHERS ARE FIXED	*
;********************************************************

FALSE	EQU	0
TRUE	EQU	NOT FALSE

MSIZE	EQU	64		;<== MEMORY SIZE IN K-BYTES
REVNUM	EQU	50		;BIOS REV #
CPMREV	EQU	22		;CP/M REV #

;	"BIAS" IS ADDRESS OFFSET FROM 3400H FOR MEMORY SYSTEMS
;	OTHER THAN 16K (REFERRED TO AS "B" THROUGHOUT THE TEXT).

BIAS	EQU	(MSIZE-20)*1024 ;ADDR OFFSET FROM 3400H (20K SYSTEM)
CCP	EQU	3400H+BIAS	;BASE OF CCP
BDOS	EQU	CCP+806H	;BASE OF BDOS
BIOS	EQU	CCP+1600H	;BASE OF BIOS
CDISK	EQU	0004H		;CURRENT CPM DISK (CONTENTS 0=A,..,15=P)
OFFSET	EQU	1F80H-BIOS	;DDT/SID BIOS OFFSET

;DMA	EQU	TRUE		;<== TRUE IF DMA OPERATION FALSE FOR IO
DMA	EQU	FALSE
;
;	IF "DMA EQU TRUE" THEN THE TOP 8 BITS OF THE 24-BIT ADDRESS
;	NEEDS TO BE SPECIFIED.  IF YOUR CPU DRIVES THE BUS WITH
;	ZEROS, THEN LEAVE THE FOLLOWING EQUATE ALONE.  IF YOUR CPU
;	DRIVES THE BUS WITH SOME STRANGE VALUE, THEN CHANGE THE
;	EQUATE TO MATCH.  IF YOUR CPU DOES NOT DRIVE THE TOP 8
;	ADDRESS BITS (SUCH AS THE W/W MPU-B) THEN A PROPERLY
;	TERMINATED BUS WILL HAVE 0FFH ON THESE BITS.  IF YOU ARE
;	NOT USING DMA OR YOUR MEMORY DOES NOT RESPOND TO EXTENDED
;	ADDRESSING THEN THIS VALUE DOES NOT MATTER.
;
;DMAEXT	EQU	0		;<== TOP 8 OF 24-BIT DMA ADDRESS
DMAEXT	EQU	0FFH


; VARIOUS CONFIGURATION EQUATES FOR THE CONSOLE DEVICE -- MODIFY AS NEEDED.
;
; SET ONLY ONE OF THE FOLLOWING EQUATES "TRUE" TO SELECT THE CP/M CONSOLE 
; DEVICE. IF YOUR CONSOLE DEVICE IS NOT LISTED HERE THEN YOU MUST MODIFY THE 
; THE I/O DRIVERS FOR YOUR DEVICE.

MPUZSIOA EQU	FALSE		;<== CONSOLE ON THE FULCRUM MPUZ SERIAL PORT A
MPUBPORT EQU	FALSE		;<== CONSOLE ON IAMSAI MPU-B SERIAL PORTS 2 3
SIO2A	EQU	FALSE		;<== FULCRUM SIO2-2 SERIAL PORT A
VIOX	EQU	TRUE		;<== FULCRUM VIOX VIDEO IO BOARD
CCS2810	EQU	FALSE		;<== CCS 2810 CPU IO BOARD
BIGZ10	EQU	FALSE		;<== JADE BIG Z BORAD AT PORT 10 AND 11
BIGZ0	EQU	FALSE		;<== JADE BIG Z BORAD AT PORT 0 AND 1

VIOXTIME EQU	FALSE		;<== SET VIOX CLOCK FROM FULCRUM MPUZ CLOCK

	IF MPUZSIOA
CRTST	EQU	21H		;<== CRT STATUS PORT
CRTDATA EQU	23H		;<== CRT DATA PORT
CRTTXR	EQU	4		;<== TRANSMIT READY MASK
CRTRXR	EQU	1		;<== CONSOLE STATUS READY BIT (RxRDY)
	ENDIF

	IF MPUBPORT OR SIO2A OR VIOX
CRTST	EQU	3H		;<== CRT STATUS PORT
CRTDATA EQU	2H		;<== CRT DATA PORT
CRTTXR	EQU	1		;<== TRANSMIT READY MASK
CRTRXR	EQU	2		;<== CONSOLE STATUS READY BIT (RxRDY)
MPUBST	EQU	03		;PORT ADDRESS FOR 8251 INITILATION
	ENDIF

	IF BIGZ10
CRTST	EQU	11H		;<== CRT STATUS PORT
CRTDATA EQU	10H		;<== CRT DATA PORT
CRTTXR	EQU	1		;<== TRANSMIT READY MASK
CRTRXR	EQU	2		;<== CONSOLE STATUS READY BIT (RxRDY)
MPUBST	EQU	11H		;PORT ADDRESS FOR 8251 INITILATION
	ENDIF

	IF BIGZ0
CRTST	EQU	1H		;<== CRT STATUS PORT
CRTDATA EQU	0H		;<== CRT DATA PORT
CRTTXR	EQU	1		;<== TRANSMIT READY MASK
CRTRXR	EQU	2		;<== CONSOLE STATUS READY BIT (RxRDY)
MPUBST	EQU	1H		;PORT ADDRESS FOR 8251 INITILATION
	ENDIF

	IF CCS2810
CRTST	EQU	25H		;<== CRT STATUS PORT
CRTDATA EQU	20H		;<== CRT DATA PORT
CRTTXR	EQU	20H		;<== TRANSMIT READY MASK
CRTRXR	EQU	1H		;<== CONSOLE STATUS READY BIT (RxRDY)
	;ALSO SEE BAUD RATE SETTINGS IN INITILATION BELOW
	ENDIF

; VARIOUS CONFIGURATION EQUATES FOR THE LIST  DEVICE -- MODIFY AS NEEDED.
;
; SET ONLY ONE OF THE FOLLOWING EQUATES "TRUE" TO SELECT THE CP/M LIST
; DEVICE IF YOUR LIST DEVICE IS NOT GIVEN HERE THEN YOU MUST MODIFY THE 
; LIST I/O DRIVER FOR YOUR DEVICE.

MPUBPAR	EQU	FALSE		;<== CENTRONIX PRINTER ON MPUB PARALELL PORT
MPUZPAR	EQU	TRUE		;<== CENTRONIX PRINTER ON MPUZ PARALELL PORT
MPUZSERB EQU	FALSE		;<== SERIAL PRINTER ON MPUZ SERIAL PORT B
SIO40B	EQU	FALSE		;<== SET TRUE FOR TI TYPE PRINTER ON SIO B 


; VARIOUS CONFIGURATION EQUATES FOR THE PUNCH READER DEVICE - MODIFY AS NEEDED.
;
; SET ONLY ONE OF THE FOLLOWING EQUATES "TRUE" TO SELECT THE CP/M READER/PUNCH 
; DEVICE IF YOUR READER/PUNCH DEVICE IS NOT LISTED HERE THEN YOU MUST MODIFY
; THE DRIVER FOR YOUR DEVICE.

RDRPUN	EQU	TRUE		;<== SET TRUE FOR READER/PUNCH ON RPDATA PORT

RPST	EQU	29H		;<== READER/PUNCH STATUS PORT
RPDATA	EQU	2BH		;<== READER/PUNCH DATA PORT
RPTXR	EQU	4		;<== READER/PUNCH TRANSMITTER READY (TxRDY)
RPRXR	EQU	1		;<== READER/PUNCH RECIEVER READY (RxRDY)

; IF YOU HAVE A FRONT PANEL SET THE FOLLOWING EQUATE TO TRUE.
; THEN FIND THE CONDITIONAL ASSEMBLY THAT IS CONTROLLED BY THIS EQUATE.
; MAKE IT DO WHATEVER YOU WANT.

FRONTP	EQU	FALSE		;CPA FRONT PANEL EQUATE

;	DISK SYSTEM EQUATES (change with care if you wish to save space)
;
;	FLOPPY DISK CONFIGURATION PARAMETERS
;
;	WDELAY AND LDELAY ARE IN UNITS OF 1/4 SECOND
;	VALID RANGE FOR BOTH: 1..255
;	WDELAY SHOULD NOT BE MUCH MORE THAN 1.5 SECONDS (EQU 6)
;	WDELAY GIVES THE MAX TIME THAT UNWRITTEN DATA IS HELD
;		THIS PARAMETER ALSO APPLIES TO HARD DISK
;	LDELAY GIVES HEAD UNLOAD TIME
;		WITH DOOR LOCKS 5 SECONDS IS ABOUT RIGHT
;		WITH MANY 1/2 AND 1/3 HEIGHT DRIVES 30-60 SECONDS IS BETTER
;
;	STEP8 RANGE: 1..16 MS
;	STEP5 RANGE: 2..32 MS (INTERNALLY ROUNED UP TO EVEN)
;	LOADx AND SETLx RANGE: 0..255 MS (BUT MUST REFLECT FLOPPY DRIVE PARMS)
;
;	6 & 20 IN NEXT TWO EQUATES GIVE 1.5 SEC AND 5 SECONDS DELAYS
;
WDELAY	EQU	6		;<== DELAY (IN 250MS TICKS) HOLDING WRITES
LDELAY	EQU	20		;<== FD HEADS LOADED AFTER USE IN 250MS TICKS
STEP8	EQU	3		;<== 8" FD STEP RATE IN MS
LOAD8	EQU	8		;<== 8" FD HEAD LOAD TIME IN MS
SETL8	EQU	0		;<== 8" FD HEAD SETTLE TIME IN MS (AFTER SEEK)
STEP5	EQU	4		;<== 5" FD STEP RATE IN MS
LOAD5	EQU	8		;<== 5" FD HEAD LOAD TIME IN MS
SETL5	EQU	0		;<== 5" FD HEAD SETTLE TIME IN MS (AFTER SEEK)
;
;	HARD DISK CONFIGURATION PARAMETERS
;
;
;	HARD DISK SELECTION -- SELECT ONLY ONE
;
CMI5616	EQU	FALSE		;<==CMI     6 HEAD 256 CYLINDERS BUFFERED SEEK
CMI5619	EQU	FALSE		;<==CMI     6 HEAD 306 CYLINDERS BUFFERED SEEK
CDCWREN EQU	FALSE		;<==CDC	    5 HEAD 697 CYLINERS BUFFERED SEEK
HH612	EQU	FALSE		;<==MICRO SCIENCE 1/2 HEIGHT
IMI5006 EQU	FALSE		;<==IMI     2 HEAD 306 CYLINDERS BUFFERED SEEK
IMI5012 EQU	FALSE		;<==IMI     4 HEAD 306 CYLINDERS BUFFERED SEEK
IMI5018	EQU	FALSE		;<==IMI     6 HEAD 306 CYLINDERS BUFFERED SEEK
SA712	EQU	FALSE		;<==SHUGART 4 HEAD 306 CYLINDERS BUFFERED SEEK
SA1004	EQU	FALSE		;<==SHUGART 4 HEAD 256 CYLINDERS BUFFERED SEEK
SQ306	EQU	TRUE		;<==SYQUEST 2 HEAD 306 CYLINDERS REMOVABLE
ST206	EQU	FALSE		;<==SEGATE 2 HEAD 306 CYLINDERS BUFFERED SEEK
ST506	EQU	FALSE		;<==SEGATE 4 HEAD 153 CYLINDERS 3 MS STEP RATE
ST406	EQU	FALSE		;<==SEGATE 2 HEAD 306 CYLINDERS BUFFERED SEEK
ST412	EQU	FALSE		;<==SEGATE 4 HEAD 306 CYLINDERS BUFFERED SEEK
ST419	EQU	FALSE		;<==SEGATE 6 HEAD 306 CYLINDERS BUFFERED SEEK
TM501	EQU	FALSE		;<==TANDON 2 HEAD 306 CYLINDERS BUFFERED SEEK
TM502	EQU	FALSE		;<==TANDON 4 HEAD 306 CYLINDERS BUFFERED SEEK
TM602S	EQU	FALSE		;<==TANDON 4 HEAD 153 CYLINDERS 3 MS STEP RATE
TM603S	EQU	FALSE		;<==TANDON 6 HEAD 153 CYLINDERS 3 MS STEP RATE
TM603SE	EQU	FALSE		;<==TANDON 6 HEAD 230 CYLINDERS 3 MS STEP RATE
;
;
;	SELECT THE TYPE OF WESTERN DIGITAL CONTROLLER YOU HAVE
;
;	IE WD1000-XX ARE CRC TYPE CONTROLLERS SET TO 20H
;	   WD1001-XX ARE ECC TYPE CONTROLLERS SET TO A0H
;	   WD1002-XX ARE ECC TYPE CONTROLLERS SET TO A0H
;
HD$CTLR EQU	020H		;<== 0A0H IF ECC CTLR ELSE 20H & NOTHING ELSE!
;				;(NOTE: ECC CONTROLLERS CAN BE USED IN NON-ECC
;				; MODE BUT NOT THE OTHER WAY AROUND.  IT IS
;				; NESSESSARY TO REFORMAT IF CHANGING FROM ECC
;				; TO NON-ECC OR BACK.)
;
;	BASED ON ABOVE EQUATES, THE FOLLOWING SYMBOLS ARE DEFINED
;
; HD$STEP   STEP RATE 0..F ==> 0.0 .. 7.5mS
; HD$PCMP   PRE-COMP TO BE USED FOR GIVEN DISK TYPE
; HD$PCYL   NUMBER OF PHYSICAL CYLINDERS IN DEVICE
; HD$NHDS   NUMBERS OF PHYSICAL (READ/WRITE) HEADS IN DEVICE
;

	
	IF IMI5006 OR ST406 OR TM501 OR SQ306
HD$STEP	EQU	0
HD$PCMP	EQU	150
HD$PCYL	EQU	306
HD$NHDS	EQU	2
	ENDIF

	IF IMI5018
HD$STEP	EQU	0
HD$PCMP	EQU	150
HD$PCYL	EQU	306
HD$NHDS	EQU	6
	ENDIF

	IF IMI5012 OR ST412 OR TM502 OR SA712 OR HH612
HD$STEP	EQU	0
HD$PCMP	EQU	150
HD$PCYL	EQU	306
HD$NHDS	EQU	4
	ENDIF

	IF SA1004
HD$STEP	EQU	0
HD$PCMP	EQU	128
HD$PCYL	EQU	256
HD$NHDS	EQU	4
	ENDIF

	IF TM602S
HD$STEP	EQU	6
HD$PCMP	EQU	75
HD$PCYL	EQU	153
HD$NHDS	EQU	4
	ENDIF

	IF TM603S
HD$STEP	EQU	6
HD$PCMP	EQU	75
HD$PCYL	EQU	153
HD$NHDS	EQU	6
	ENDIF

	IF TM603SE
HD$STEP	EQU	6
HD$PCMP	EQU	75
HD$PCYL	EQU	230
HD$NHDS	EQU	6
	ENDIF


;
;	NOTE TO OMNIDISK USERS:
;
;	WE ARE SORRY THAT THE HARD DISK DEFINATION TABLES ARE SUCH A ZOO.
;	THERE WERE SEVERAL CONFLICTING DESIGN OBJECTIVES AND ABILITY TO USE
;	THE STANDARD DR "ASM" ASSEMBLER WON OUT OVER A MACRO OR TWO THAT
;	WOULD HAVE MADE YOUR TASK EASIER.
;
;	IF YOU HAVE ONLY ONE HARD DISK, AND THAT HARD IS CONFIGURED AS ONLY
;	ONE LOGICAL UNIT, THEN ALL WILL BE AUTOMATIC.
;
;	WHATEVER YOU DO, PLEASE REMEMBER THAT IN THE EQUATES FOR ALL THOSE
;	ALV$x, CKV$x AND DEV$x YOU ALSO NEED TO DEFINE HDLU$n AND TO USE
;	THAT VALUE IN THE OC$HDTB INIT CODE.
;
;	IF YOU HAVE A LARGE HARD DISK AND NEED SEVERAL LOGICAL DEVICES,
;	THEN YOU NEED TO DEFINE THE SIZE OF EACH PIECE.  THE SYMBOL
;	DEFINATIONS THAT FOLLOW JUST MAY BE OF SOME USE.  SEE ALSO THE
;	USE OF HD$BASE0 AND HD$SIZE0 IN THE INIT SECTION.
;
;	IF ONE OR MORE OF YOUR HARD DISK SEGMENTS IS LESS THAN 8 MEG (1000
;	TRACKS OR 2000 ALLOCATION UNITS) THEN YOU CAN SAVE ALLOCATION VECTOR
;	SPACE BY ASSURING THAT "ALV$x EQU (HD$SIZEn+3)/4" WHERE x IS THE CP/M
;	DRIVE LETTER (A: TO P:) AND n IS 0 TO 3 DEFINED BELOW.
;
;
HD$0	EQU	0H		;** THESE VALUES SELECT THE PHYSICAL DRIVE 
HD$1	EQU	8H		;** THAT A LOGICAL DRIVE RESIDES ON 
HD$2	EQU	10H		;** AND ARE SELECTED IN THE TABLES BELOW
HD$3	EQU	18H		;** FOR EACH LOGICAL DRIVE

HD$USE	EQU	FALSE		;<== SET FALSE IF NO HARD DISK ON OMNIDISK

	IF HD$USE
NHDISKS EQU	1		;<== TOTAL NUMBER OF LOGICAL HARD DISKS 
;NHDISKS EQU	2
	ENDIF

	IF NOT HD$USE
NHDISKS EQU	0		;DESELECT ALL HARD DISKS IF HD$USE=FALSE
	ENDIF

HD$USE0	EQU	(NHDISKS+99)/100	;LOGICAL HARD DISK 0  (PLEASE SEE
HD$USE1	EQU	(NHDISKS+99)/101	;LOGICAL HARD DISK 1   BOTH USES
HD$USE2	EQU	(NHDISKS+99)/102	;LOGICAL HARD DISK 2   OF EACH OF
HD$USE3	EQU	(NHDISKS+99)/103	;LOGICAL HARD DISK 3   THESE SYMBOLS)

HD$SPACE SET	HD$PCYL*HD$NHDS
HD$ORG	SET	0

	IF HD$USE0
;HD$SIZE0 EQU	HD$SPACE-2	;ALAS, ASM GAVE PHASE ER FOR THIS LINE
HD$SIZE0 EQU	HD$PCYL*HD$NHDS-2 ;SO...LINE WAS CHANGED TO THIS
;HD$SIZE0 EQU	223		;<== 1000 TRACKS MAX FOR CP/M 2.2 (1 TRK = 8K)
HD$SEL0	EQU	HD$0		;<== SET FOR THE PHYSICAL HARD DRIVE SELECT
HD$BASE0 EQU	HD$ORG
HD$SPACE SET	HD$SPACE-HD$SIZE0-2	;SPACE LEFT AFTER FIRST HARD DISK SEG
HD$ORG	SET	HD$ORG+HD$SIZE0+2	;ORG FOR NEXT LOGICAL HARD DISK
; NOTE: THE "-2" IS 2 TRACKS RESERVED FOR THE SYSTEM
	ENDIF

	IF HD$USE1
HD$SIZE1 EQU	1000		;<== SECOND SEGMENT SIZE
HD$SEL1	EQU	HD$0		;<== SET FOR THE PHYSICAL HARD DRIVE SELECT
HD$BASE1 EQU	HD$ORG
HD$SPACE SET	HD$SPACE-HD$SIZE1-2	;SPACE LEFT AFTER SECOND HARD DISK SEG
HD$ORG	SET	HD$ORG+HD$SIZE1+2	;ORG FOR NEXT LOGICAL HARD DISK
	ENDIF

	IF HD$USE2
HD$SIZE2 EQU	0		;<== THIRD SEGMENT SIZE
HD$SEL2	EQU	HD$0		;<== SET FOR THE PHYSICAL HARD DISK
HD$BASE2 EQU	HD$ORG
HD$SPACE SET	HD$SPACE-HD$SIZE2-2	;SPACE LEFT AFTER THIRD HARD DISK SEG
HD$ORG	SET	HD$ORG+HD$SIZE2+2	;ORG FOR NEXT LOGICAL HARD DISK
	ENDIF

	IF HD$USE3
HD$SIZE3 EQU	0		;<== FOURTH SEGMENT SIZE
HD$SEL3	EQU	HD$0		;<== SET FOR THE PHYSICAL HARD DISK
HD$BASE3 EQU	HD$ORG
HD$SPACE SET	HD$SPACE-HD$SIZE3-2	;SPACE LEFT AFTER FOURTH HARD DISK SEG
	ENDIF

;
;	OMNIDISK DMA PRIORITY IS SET BY SOFTWARE, NOT BY A DIP SWITCH.
;
;	SELECT WHATEVER PRIORITY YOU DESIRE --
;	00H IS THE LOWEST, 0FH IS THE HIGHEST.
;
;	OMNIDISK RUNS WELL WITH THE LOWEST PRIORITY BECAUSE IT
;	IS NEVER DOING ANYTHING TIME-CRITICAL WHEN DMA IS USED.
;
;	THERE ARE ONLY THREE CASES WHERE THE OMNIDISK CONTROLLER USES
;	DMA.  (1) READ/WRITE OPERATIONS WHEN THE BIOS IS ASSEMBLED
;	WITH DMA=TRUE.  (2) ANY ACCESS TO THE MEMORY DISK, EVEN IF
;	THE BIOS IS ASSEMBLED WITH DMA=FALSE.  (3) THE OC$MOVM COMMAND
;	WHICH MOVES A BLOCK OF MEMORY USING DMA.  OC$MOVM IS NOT USED
;	BY THE BIOS OR ANY UTILITY FUNCTION PROVIDED BY W/W OR FULCRUM.
;
;	IF DMA IS BROKEN IN YOUR SYSTEM, AVOID THE ABOVE 3 CONDITIONS
;	AND ENJOY MOST OF THE OMNIDISK ADVANTAGES.
;
DMAPRI	EQU	0		;<== DMA PRIORITY
;
;******************************************************************************

;******************************************************************************
;	BEGIN MEMORY DISK DEFINATION
;******************************************************************************
;******************************************************************************
;
MD$USE	EQU	FALSE		;<== CHANGE TO ASSEMBLE MEMORY DISK
;
;	REQUIRED READING FOR USERS OF THE MEMORY DISK --
;
;	ALL LINES IN THIS SECTION WITH ";<==" MUST BE READ AND UNDERSTOOD.
;	MAKE CHANGES TO REFLECT HOW YOUR SYSTEM IS CONFIGURED.
;
	IF	MD$USE
;
;	SIZE AND BASE OF MEMORY DISK BLOCKS --
;
;	YOU MAY HAVE UP TO 4 AREAS WITHIN THE S-100
;	ADDRESS SPACE THAT ARE TO BE USED AS MEMORY DISK.
;
;	THESE AREAS ARE DEFINED HERE IN TERMS OF 64K BLOCKS.
;	MD$Sx VALUES GIVE THE SIZE OR NUMBER OF 64K BLOCKS
;	IN THE GIVEN GROUP.  MD$Bx VALUES GIVE THE HIGH ORDER
;	8 BITS OF THE LOWEST ADDRESS IN THE GROUP.
;
MD$S1	EQU	4		;<== # 64K BLOCKS...
MD$B1	EQU	080H		;<== ...STARTING AT "MD$B1"0000H
MD$S2	EQU	0		;<== # 64K BLOCKS...
MD$B2	EQU	0		;<== ...STARTING AT "MD$B2"0000H
MD$S3	EQU	0		;<== # 64K BLOCKS...
MD$B3	EQU	0		;<== ...STARTING AT "MD$B3"0000H
MD$S4	EQU	0		;<== # 64K BLOCKS...
MD$B4	EQU	0		;<== ...STARTING AT "MD$B4"0000H
;
;	*************************************************
;	* ALL COMMENTS AND EQUATES FOR MEMORY DISK	*
;	* ASSUME 2K ALLOCATION SIZE.  THERE IS NOTHING	*
;	* IN THE OMNIDISK (tm) CONTROLLER THAT REQUIRES	*
;	* THIS.  FOR SMALL (64K OR 128K) MEMORY DISKS,	*
;	* A 1K ALLOCATION SIZE WOULD BE SLIGHTLY BETTER.*
;	* FOR LARGE (STARTING AT 1 OR 2 MEG) MEMORY	*
;	* DISKS, AN ALLOCATION SIZE OF 4K WOULD REDUCE	*
;	* SYSTEM MEMORY REQUIREMENTS BY ENOUGH TO MAKE	*
;	* THE CHANGE WORTH THE BOTHER.			*
;	*						*
;	* CONSULT THE DIGITAL RESEARCH CP/M ALTERATION	*
;	* GUIDE FOR REQUIRED KNOWLEDGE.			*
;	*************************************************
;
;	IF YOU HAVE MORE THAN 8 64K BLOCKS OF MEMORY DISK,
;	YOU MUST CHANGE THE FOLLOWING EQUATE.
;
MD$EXM	EQU	1		;<== CHANGE TO "EQU 0" IF > 512K MEMORY DISK
;
;	SETUP MEMORY DISK DIRECTORY SPACE --
;
;	PLEASE NOTE THAT HAVING MORE DIRECTORY SPACE THAN ALLOCATION
;	UNITS ONLY COSTS YOU SPACE.  SEE MD$AL BELOW.  DECIDE ON
;	A REASONABLE MAXIMUM NUMBER OF FILES, DIVIDE BY 32 TO GET
;	DIRECTORY SPACE IN BLOCKS.
;
;	THE MAXIMUM NUMBER OF DIRECTORY BLOCKS IS 16.  THIS GIVES
;	A MAXIMUM OF 512 FILE ENTRIES (USING 2K ALLOCATION SIZE).
;
;	SEE COMMENTS ON MD$Vxx EQUATES FOR THE MAXIMUM NUMBER OF FILE ENTRIES.
;
;	("NUMBER OF FILE ENTRIES" IS PERHAPS BETTER STATED AS "NUMBER OF
;	 EXTENTS".  THE MAXIMUM NUMBER OF FILES MAY BE SOMEWHAT LESS
;	 BECAUSE LARGE FILES TAKE MORE THAN ONE EXTENT.  ONE EXTENT
;	 IS 32K IF MD$EXM=0; THE EXTENT SIZE DROPS TO 16K IF MD$EXM=1.)
;
MD$DBLK	EQU	2		;<== NUMBER OF MEMORY DISK DIRECTORY BLOCKS
MD$FILES EQU	MD$DBLK*32
;
;	NOW SET THE DIRECTORY ALLOCATION VECTOR.
;
;	EQUATE MD$AL01 TO ONE OF THE FOLLOWING SYMBOLS
;
;							SUGGESTED
;					      FILES	MEM DSK SIZE
;					      -----	------------
MD$V1	EQU	00080H	;USE IF MD$DBLK = 1	 32	 64K - 128K
MD$V2	EQU	000C0H	;USE IF MD$DBLK = 2	 64	128K - 256K
MD$V3	EQU	000E0H	;USE IF MD$DBLK = 3	 96	192K - 512K
MD$V4	EQU	000F0H	;USE IF MD$DBLK = 4	128	256K - 1 MEG
MD$V5	EQU	000F8H	;USE IF MD$DBLK = 5	160	320K - 1.5 MEG
MD$V6	EQU	000FCH	;USE IF MD$DBLK = 6	192	394K - 2 MEG
MD$V7	EQU	000FEH	;USE IF MD$DBLK = 7	224	448K - 2.5 MEG
MD$V8	EQU	000FFH	;USE IF MD$DBLK = 8	256	512K - 3 MEG
MD$V9	EQU	080FFH	;USE IF MD$DBLK = 9	288	576K - 3.5 MEG
MD$V10	EQU	0C0FFH	;USE IF MD$DBLK = 10	320	640K - 4 MEG
MD$V11	EQU	0E0FFH	;USE IF MD$DBLK = 11	352	704K - 4.5 MEG
MD$V12	EQU	0F0FFH	;USE IF MD$DBLK = 12	384	768K - 5 MEG
MD$V13	EQU	0F8FFH	;USE IF MD$DBLK = 13	416	832K - 5.5 MEG
MD$V14	EQU	0FCFFH	;USE IF MD$DBLK = 14	448	896K - 6 MEG
MD$V15	EQU	0FEFFH	;USE IF MD$DBLK = 15	480	960K - 7 MEG
MD$V16	EQU	0FFFFH	;USE IF MD$DBLK = 16	512	1 MEG AND UP

MD$AL01	EQU	MD$V2		;<== ALLCATION BIT MAP FOR DIRECTORY
;
;	AGAIN, FOR...
;
;		MD$DBLK	 EQU	nn
;
;	THE ABOVE EQUATE MUST BE...
;
;		MD$AL01	 EQU	MD$Vnn
;
MD$SCYL	EQU	0		;<== "CYLINDERS" FOR SYSTEM ON MEMORY DISK
;
;	EACH "CYLINDER" IS 8K.  IF MD$SCYL=0 THEN NO SYSTEM IMAGE MAY BE
;	WRITTEN TO THE MEMORY DISK.  ONLY DISKS CONTAINING THE OPERATING
;	SYSTEM MAY BE ASSIGNED AS THE A: DISK.
;
MD$AL  EQU  (MD$S1+MD$S2+MD$S3+MD$S4)*32-(4*MD$SCYL) ;MD SIZE IN 2K ALLOC UNITS

ALVMD	EQU	(MD$AL+7)/8	;ALLOC VECT (4 BYTES/64K)

; ALV$x	 EQU	ALVMD		;<== (DONT FORGET TO SETUP
; CKV$x	 EQU	CKVMD		;<==  A CP/M LOGICAL UNIT
; DEV$x	 EQU	MDISK		;<==  IN THE DRIVE TABLE)

	ENDIF

	IF NOT MD$USE
ALVMD	EQU	0		;SET TO NOT USED
	ENDIF

;******************************************************************************
;******************************************************************************
;	END OF MEMORY DISK DEFINATION
;******************************************************************************
;******************************************************************************

;******************************************************************************
;
;	DISK SYSTEM EQUATES (change with care if you wish to save space)

ALV5	EQU	38		;MAX ALLOCATION VECTOR LENGTH FOR 5" FLOPPY
ALV8	EQU	75		;MAX ALLOCATION VECTOR LENGTH FOR 8" FLOPPY

CKV5	EQU	48		;5" FD CHECK VECTOR LENGTH (192 FILES)
CKV8	EQU	32		;8" FD CHECK VECTOR LENGTH (128 FILES)
CKVHD	EQU	0		;HARD DISK CHECK VECTOR NOT USED
CKVMD	EQU	0		;MEMORY DISK CHECK VECTOR NOT USED
FDISK8	EQU	10H		;OMNI DEV TYPE FOR 8" FLOPPY
FDISK5	EQU	14H		;OMNI DEV TYPE FOR 5" FLOPPY
HDISK	EQU	18H		;OMNI DEV TYPE FOR HARD DISK
MDISK	EQU	1CH		;OMNI DEV TYPE FOR MEMORY DISK

NDISKS	EQU	4		;<== NUMBER OF LOGICAL DISK DRIVES 


ALV$B	EQU	ALV8		;<== SET A: FOR 8"
CKV$B	EQU	CKV8		;<== SET A: FOR 8"
DEV$B	EQU	FDISK8+0	;<== SET A: FOR 8" UNIT 0

ALV$C	EQU	ALV8		;<== SET B: FOR 8"
CKV$C	EQU	CKV8		;<== SET B: FOR 8"
DEV$C	EQU	FDISK8+1	;<== SET B: FOR 8" UNIT 1

ALV$D	EQU	ALV5		;<== SET C: FOR 5"
CKV$D	EQU	CKV5		;<== SET C: FOR 5"
DEV$D	EQU	FDISK5+1	;<== SET C: FOR 5" UNIT 0

ALV$A	EQU	alv5		;<== SET D: FOR HARD DISK
CKV$A	EQU	ckv5		;<== SET D: FOR HARD DISK
DEV$A	EQU	fdisk5+0 	;<== SET D: FOR HARD DISK UNIT 0
;HDLU$0	EQU	'A'-'A'		;<== LOGICAL HARD DISK 0 IS CP/M D:

;ALV$E	EQU	(HD$SIZE1+3)/4	;<== SET E: FOR HARD DISK
;CKV$E	EQU	CKVHD		;<== SET E: FOR HARD DISK
;DEV$E	EQU	HDISK+1		;<== SET E: FOR HARD DISK UNIT 1
;HDLU$1	EQU	'E'-'A'		;<== LOGICAL HARD DISK 1 IS CP/M E:

ALV$F	EQU	ALVMD		;<== SET F: FOR MEMORY DISK
CKV$F	EQU	CKVMD		;<== SET F: FOR MEMORY DISK
DEV$F	EQU	MDISK		;<== SET F: FOR MEMORY DISK (NO UNIT NUMBER)
	
ALV$G	EQU	0		;<== SET G: FOR UNUSED
CKV$G	EQU	0		;<== SET G: FOR UNUSED
DEV$G	EQU	0		;<== SET G: FOR UNUSED

ALV$H	EQU	0		;<== SET H: FOR UNUSED
CKV$H	EQU	0		;<== SET H: FOR UNUSED
DEV$H	EQU	0		;<== SET H: FOR UNUSED

ALV$I	EQU	0		;<== SET I: FOR UNUSED
CKV$I	EQU	0		;<== SET I: FOR UNUSED
DEV$I	EQU	0		;<== SET I: FOR UNUSED

ALV$J	EQU	0		;<== SET J: FOR UNUSED
CKV$J	EQU	0		;<== SET J: FOR UNUSED
DEV$J	EQU	0		;<== SET J: FOR UNUSED

ALV$K	EQU	0		;<== SET K: FOR UNUSED
CKV$K	EQU	0		;<== SET K: FOR UNUSED
DEV$K	EQU	0		;<== SET K: FOR UNUSED

ALV$L	EQU	0		;<== SET L: FOR UNUSED
CKV$L	EQU	0		;<== SET L: FOR UNUSED
DEV$L	EQU	0		;<== SET L: FOR UNUSED

ALV$M	EQU	0		;<== SET M: FOR UNUSED
CKV$M	EQU	0		;<== SET M: FOR UNUSED
DEV$M	EQU	0		;<== SET M: FOR UNUSED

ALV$N	EQU	0		;<== SET N: FOR UNUSED
CKV$N	EQU	0		;<== SET N: FOR UNUSED
DEV$N	EQU	0		;<== SET N: FOR UNUSED

ALV$M	EQU	0		;<== SET M: FOR UNUSED
CKV$M	EQU	0		;<== SET M: FOR UNUSED
DEV$M	EQU	0		;<== SET M: FOR UNUSED

ALV$O	EQU	0		;<== SET O: FOR UNUSED
CKV$O	EQU	0		;<== SET O: FOR UNUSED
DEV$O	EQU	0		;<== SET O: FOR UNUSED

ALV$P	EQU	0		;<== SET P: FOR UNUSED
CKV$P	EQU	0		;<== SET P: FOR UNUSED
DEV$P	EQU	0		;<== SET P: FOR UNUSED

;******************************************************************************
;
;	PARAMATERS BELOW THIS POINT SHOULD REQUIRE NO MODS
;
;	THERE ARE, HOWEVER, A FEW LINES BEYOND THIS POINT
;	THAT CAN BE CHANGED IF YOU WISH.  USE YOUR TEXT EDITOR
;	TO SEARCH FOR ";<== " AND AT LEAST READ THE COMMENTS.
;
; 	IN PARTICULAR, SEE ";<== " IN HARD DISK SETUP SECTION.
;	YOU MAY WISH TO CHANGE SIZE OF DIRECTORY.
;
;******************************************************************************


; USEFUL THINGS TO KNOW:

;	. MPU-B OR SIO-2 STATUS PORT
;	. ( TERMINAL REFERENCED AS TRANSMITTER )

;	0 = TxRDY	TRANSMITTER READY
;	1 = RxRDY	RECEIVER READY
;	2 = TxE		TRANSMITTER EMPTY
;	3 = PE		PARITY ERROR
;	4 = OE		OVERRUN ERROR
;	5 = FE		FRAMING ERROR
;	6 = SYNDET	SYCN DETECT
;	7 = DSR		DATA SET READY

;	. CONSOLE STATUS PORT (IN HEX) - 15 = PARALLEL
;					 13 OR 5 = SERIAL
;					 3 = SYSTEM
;
;	. CONSOLE DATA PORT (IN HEX) - 14 = PARALLEL
;				       12 OR 4 = SERIAL
;				       2 = SYSTEM


;	MPUZ PORT DEFINATIONS

MPUZBASE EQU	20H		;<== BASE PORT OF MPUZ (MULTIPLE OF 20H ONLY)
				;20H WORKS WITH FULCRUM PROVIDED UTILITIES

;	PORT DEFINATIONS ON 2681 DUAL SERIAL PORT CONTROLLER

DUART	EQU	MPUZBASE	;BASE PORT OF 2681
MRA	EQU	DUART+00H	;PORT A MODE REGISTER (READ/WRITE)
SRA	EQU	DUART+01H	;PORT A STATUS REGISTER (READ ONLY)
CSRA	EQU	DUART+01H	;PORT A CLOCK SELECT (WRITE ONLY)
;		DUART+02H	;RESERVED (READ ONLY)
CRA	EQU	DUART+02H	;PORT A COMMAND REGISTER (WRITE ONLY)
DATAA	EQU	DUART+03H	;PORT A DATA REGISTER (READ/WRITE)
IPCR	EQU	DUART+04H	;INPUT PORT CHANGE REGISTER (READ ONLY)
ACR	EQU	DUART+04H	;AUX CONTROL REGISTER (WRITE ONLY)
ISR	EQU	DUART+05H	;INTERRUPT STATUS REGISTER (READ ONLY)
IMR	EQU	DUART+05H	;INTERRUPT MASK REGISTER (WRITE ONLY)
CTU	EQU	DUART+06H	;COUNTER/TIMER UPPER REGISTER (READ/WRITE)
CTL	EQU	DUART+07H	;COUNTER/TIMER LOWER REGISTER (READ/WRITE)
MRB	EQU	DUART+08H	;PORT B MODE REGISTER (READ/WRITE)
SRB	EQU	DUART+09H	;PORT B STATUS REGISTER (READ ONLY)
CSRB	EQU	DUART+09H	;PORT B CLOCK SELECT (WRITE ONLY)
;		DUART+0AH	;RESERVED (READ ONLY)
CRB	EQU	DUART+0AH	;PORT B COMMAND REGISTER (WRITE ONLY)
DATAB	EQU	DUART+0BH	;PORT B DATA REGISTER (READ/WRITE)
;		DUART+0CH	;RESERVED (READ/WRITE)
DUAINP	EQU	DUART+0DH	;DUART IP7..IP0 (READ ONLY)
OPCR	EQU	DUART+0DH	;OUTPUT PORT CONFIG REGISTER (WRITE ONLY)
STARTC	EQU	DUART+0EH	;START COUNTER COMMAND WHEN READ
SETOPB	EQU	DUART+0EH	;SET OUTPUT BITS COMMAND (WRITE ONLY)
STOPC	EQU	DUART+0FH	;STOP COUNTER COMMAND WHEN READ
RESOPB	EQU	DUART+0FH	;RESET OUTPUT BITS COMMAND (WRITE ONLY)
TXRDY2681 EQU	4		;TRANSMIT READY MASK (TxRDY)
RXRDY2681 EQU	1		;RECIEVE READY MASK (RxRDY)

;	OTHER STUFF ON MPUZ....

;	CENTRONIX STYLE PRINTER PORTS

PARAA	EQU	MPUZBASE+10H	;MPUZ 8255 CENTRONIX DATA PORT
PARAB	EQU	MPUZBASE+11H	;MPUZ 8255 CENTRONIX STATUS PORT
PARAC	EQU	MPUZBASE+12H	;MPUZ 8255 CENTRONIX STROBE PORT
PARACTL	EQU	MPUZBASE+13H	;MPUZ 8255 CENTRONIX MODE PORT

;	8259A INTERRUPT CONTROLLER
;	NOTE: THE 8259A IS NOT USED IN THE STANDARD BIOS
;	      PORT EQUATES ARE FOR REFERENCE

INT0	EQU	MPUZBASE+14H	;A0=0
INT1	EQU	MPUZBASE+15H	;A0=1

;	WALL CLOCK EQUATES
;
;	ADR PORT: CB A9 87	54 32 10	6
;		  YY/MM/DD	HH:MM:SS	DAY OF WEEK
;
;		MM IS 00..11		DAY OF WEEK IS 0..6
;					USE AS SUNDAY..SATURDAY
;
;	NOTE:	THE WALL CLOCK IS USED IN THE STANDARD BIOS ONLY IF
;		VIOXTIME IS SET TRUE TO CAUSE THE VIOX CLOCK TO BE
;		SET FROM THE MPUZ CLOCK.

CSTAT	EQU	MPUZBASE+1CH	;WAIT FOR MSB BEFORE SETTING CADR
CADR	EQU	MPUZBASE+18H	;SELECTS WHICH DIGIT IS RETURNED OR SET
CDATA	EQU	MPUZBASE+19H	;CLOCK DIGIT

;	MEMORY MAP REGISTER IS NOT USED IN STANDARD BIOS
;
;	THIS REGISTER IS WRITE-ONLY AND TAKES EFFECT ON THE NEXT INSTRUCTION.
;	THIS REGISTER EFFECTS INSTRUCTION FETCHES AS WELL AS DATA ACCESS.

EXTADR	EQU	MPUZBASE+1CH	;SELECTS TOP 8 BITS OF S-100 ADRS LINES

;	CCS 2810 Serial Port equates
;
SDATA:	EQU	20H	;SERIAL DATA PORT
SINTEN:	EQU	SDATA+1	;SERIAL INTERRUPT ENABLE PORT
SIDENT:	EQU	SDATA+2	;SERIAL INTERRUPT IDENTIFICATION PORT
SLCTRL:	EQU	SDATA+3	;SERIAL LINE CONTROL PORT
SMDMCT:	EQU	SDATA+4	;SERIAL MODEM CONTROL PORT
SLSTAT:	EQU	SDATA+5	;SERIAL LINE STATUS PORT
SMDMST:	EQU	SDATA+6	;SERIAL MODEM STATUS PORT

OMNIDATA EQU	0A0H		;<== DATA PORT FOR OMNI CONTROLLER
				;0A0H WORKS WITH FULCRUM PROVIDED UTILITIES
OMNISTAT EQU	OMNIDATA+1	;STATUS PORT FOR OMNI
OMNI$IN	 EQU	01H		;OMNI HAS DATA TO SEND
OMNI$OUT EQU	80H		;OMNI CAN NOT ACCEPT ANOTHER BYTE NOW


	IF (NDISKS+99)/104
ASMDPH	EQU	FALSE		;>4 DRIVES: SAVE SPACE BY MAKING DPH AFTER BOOT
	ENDIF
	IF NOT (NDISKS+99)/104
ASMDPH	EQU	TRUE		;1-4 DRIVES: ASSEMBLE IN DPH
	ENDIF


;********************************************************
;	ASCII CHARACTER EQUATES				*
;********************************************************

LF	EQU	0AH		;LINE FEED
CR	EQU	0DH		;CARRIAGE RETURN
BEL	EQU	07H		;CONSOLE BELL

;********************************************************
;	COMMAND CODES FOR OMNI CONTROLLER		*
;********************************************************

OC$BOOT	EQU	0		;BOOT SYSTEM
;C$SWRT	EQU	1		;WRITE SYSTEM (INVERSE OF BOOT)
OC$MODE EQU	2		;DMA/IO MODE
;C$FMTF	EQU	3		;FORMAT FLOPPY TRACK
OC$DLDS EQU	4		;DEFINE LOGICAL DEVICE SET
;C$GLDS	EQU	5		;GET LOGICAL DEVICE SET
;C$FWRT	EQU	6		;FORCE WRITE OF MODIFIED BUFFERS
;C$RSBP EQU	7		;RESET BOOT PHANTOM
;C$SKEW	EQU	8		;SET NON-STANDARD SKEW FACTOR
OC$UNIT	EQU	9		;SELECT (LOGICAL) UNIT
OC$TRAK	EQU	10		;SELECT TRACK
OC$RECD	EQU	11		;SELECT (LOGICAL) RECORD
OC$DADR	EQU	12		;SET DMA ADDRESS
OC$READ	EQU	13		;READ
OC$WRIT	EQU	14		;WRITE
;C$HEAD	EQU	15		;SET HEAD (RESERVED FOR FUTURE USE)
;C$MOVM	EQU	16		;MOVE BLOCK OF MEMORY WITH DMA
OC$GDPB	EQU	17		;GET DPB (GET CP/M DPB FROM OMNI)
OC$DFMD	EQU	18		;DEFINE MEMORY DISK
;C$SSEK EQU	19		;NON-IMPYED SEEK (NOT USED IN BIOS)
;C$TIOR	EQU	20		;DEBUG READS FROM OMNI
;C$TIOW	EQU	21		;DEBUG WRITES TO OMNI
OC$GENS EQU	22		;GET GENERAL STATUS
OC$EXTS	EQU	23		;GET EXTENDED STATUS
;C$SRTY	EQU	24		;SET COUNTERS FOR (FLOPPY DISK) RETRY LOGIC
;C$DPBX	EQU	25		;GET EXTENDED DPB (CP/M 3.0)
;C$GBPB	EQU	26		;GET MS-DOS "BIOS PARAMETER BLOCK"
;C$GMCS	EQU	27		;GET MS-DOS "MEDIA CHANGE STATUS"
OC$SFDP	EQU	28		;SET FLOPPY DISK PARAMETERS
;C$PREA	EQU	29		;PHYSICAL SECTOR READ
;C$PWRI	EQU	30		;PHYSICAL SECTOR WRITE
OC$HDPR	EQU	31		;HARD DISK PARMS (#HDS, PCOMP, STP R, CTLR TYP)
OC$HDTB	EQU	32		;HARD DISK TABLES--DEV SEL, PHYS OFFSET, OS TBL
OC$IERR	EQU	33		;IGNORE READ ERROR, XFER DATA ANYWAY (FLOPPY)

;	ALL OTHER EQUATES (do not change)

IOBYTE	EQU	3		;INTEL I/O BYTE
TPA	EQU	100H		;START OF TRANSIENT PGM AREA

LENBSTRAP EQU	40H		;LENGTH RESERVED FOR BOOTSTRAP
BSORG	EQU	CCP-LENBSTRAP	;BOOTSTRAP ORGIN AS ASSEMBLED
				;NOTE: BOOTSTRAP IS LOADED INTO
				;      AND RUNS AT LOCATION 0000
	ORG	BSORG

	LXI	SP,100H
	LXI	H,BSLIST-BSORG
	MVI	C,5		;LENGTH OF COMMAND LIST
BS1:
	IN	OMNISTAT
	RAL
	JC	BS1-BSORG	;IF RECEIVER FULL
	MOV	A,M		;NEXT BYTE TO SEND
	INX	H
	OUT	OMNIDATA
	DCR	C
	JNZ	BS1-BSORG	;IF MORE COMMAND LIST TO SEND

	LXI	H,BSORG		;BOOT ADDRESS
BS2:	IN	OMNISTAT
	RAR
	JNC	BS2-BSORG	;IF DATA NOT READY
	ANI	40H		;(HAS OC$GENS BEEN ACCEPTED)
	IN	OMNIDATA	;TAKE A BYTE OF THE SYSTEM -OR- GENERAL STATUS
	JZ	BS3-BSORG	;IF WE HAVE JUST READ GENERAL STAT
	MOV	M,A
	INX	H
	JMP	BS2-BSORG

BS3:	ORA	A
	JZ	CBOOT		;IF GOOD STATUS ENTER COLD BOOT ENTRY IN BIOS
	HLT			;ELSE...DIE IF ANY ERROR IN BOOT

	IF	($-BSORG)/(LENBSTRAP-5)
 EQU $-BSORG	;LENGTH OF BOOTSTRAP MAXIMUM IS LENBSTRAP-5 ...	SEE LISTING
	ENDIF

	ORG	CCP-5

BSLIST:	DB	OC$UNIT,0	;SET DRIVE 0 (A:)
	DB	OC$BOOT		;BOOT
	DB	(BOOTLEN+127)/128  ;BOOT LENGTH
	DB	OC$GENS		;GET GENERAL STATUS


;********************************************************
;							*
;	START OF BIOS FUNCTIONAL CODE			*
;							*
;********************************************************

	ORG	BIOS		;ORIGIN OF BIOS
;
;	Please do NOT try to rearrange the following jump vector.
;	CP/M calls the various subroutines by jump vector offset.
;
	JMP	CBOOT		;COLD START
WBOOTE:	JMP	WBOOT		;WARM START
	JMP	IOCONST		;CONSOLE STATUS
	JMP	IOCONIN		;CONSOLE CHAR IN
	JMP	IOCONOUT	;CONSOLE CHAR OUT
	JMP	IOLIST		;LIST CHAR OUT
	JMP	IOPUNCH		;PUNCH CHAR OUT
	JMP	IOREADER	;READER CHAR OUT
	JMP	HOME		;MOVE HEAD TO HOME POSITION
	JMP	SELDSK		;SELECT DISK
	JMP	SETTRK		;SET TRK #
	JMP	SETSEC		;SET SECT #
	JMP	SETDMA		;SET DMA ADDR
	JMP	READ		;READ DISK
	JMP	WRITE		;WRITE DISK
	JMP	IOLISTST	;RETURN LIST STATUS
;	JMP	SECTRAN		;SECT TRANSLATE
	MOV H,B ! MOV L,C ! RET ;REPLACE 3-BYTE JMP WITH 3-BYTE ROUTINE

;********************************************************
;	ACCESS PHYSICAL DEVICE DEPENDING ON CONTENTS	*
;	OF IOBYTE. INITIALIZED BY "IOINITIO" CODE.	*
;							*
;	PLEASE NOTE THE ONE-BYTE ADDRESSES USED BY	*
;	DISPATCH.  THIS SPACE SAVING METHOD SHOULD	*
;	NOT MAKE A PROBLEM, BUT IF IT DOES CONSIDER	*
;	PUTTING THE LONGEST I/O ROUTINE LAST.  OR	*
;	YOU COULD INSTALL A JMP TO A DISTANT ACCESS	*
;	ROUTINE.  IT WILL HELP IF THE DISPATCH		*
;	CALLS (PLUS THE 5 DB'S) ARE PLACED JUST		*
;	BEFORE THE REFERENCED ACCESS SUBROUTINES.	*
;********************************************************

;********
;
;	CONSOLE STATUS - CON:
;
UD$CONST EQU	FALSE		;<== USE DISPATCH FOR IOCONST IF TRUE
				;(IF FALSE, THEN CRTSTAT IS ASSUMED)
	IF UD$CONST
IOCONST:
	CALL	DISPATCH
	DB	1		;USE IOBYTE BITS 1-0
	DB	CRTSTAT-$	;00 - TTY: (CRT STATUS)
	DB	CRTSTAT-$	;01 - CRT:	"
	DB	CRTSTAT-$	;10 - BAT:	"
	DB	CRTSTAT-$	;11 - UC1:	"
	ENDIF

;********
;
;	CONSOLE IN - CON:
;
UD$CONIN EQU	FALSE		;<== USE DISPATCH FOR IOCONIN IF TRUE
				;(IF FALSE, THEN CRTIN IS ASSUMED)
	IF UD$CONIN
IOCONIN:
	CALL	DISPATCH
	DB	1		;USE IOBYTE BITS 1-0
	DB	CRTIN-$		;00 - TTY: (CRT INPUT)
	DB	CRTIN-$		;01 - CRT:	"
	DB	CRTIN-$		;10 - BAT:	"
	DB	CRTIN-$		;11 - UC1:	"
	ENDIF

;********
;
;	CONSOLE OUT - CON:
;
UD$CONOUT EQU	FALSE		;<== USE DISPATCH FOR IOCONOUT IF TRUE
				;(IF FALSE, THEN CRTOUT IS ASSUMED)
	IF UD$CONOUT
IOCONOUT:
	CALL	DISPATCH
	DB	1		;USE IOBYTE BITS 1-0
	DB	CRTOUT-$	;00 - TTY: (CRT OUTPUT)
	DB	CRTOUT-$	;01 - CRT:	"
	DB	CRTOUT-$	;10 - BAT:	"
	DB	CRTOUT-$	;11 - UC1:	"
	ENDIF

;********
;
;	LIST OUT - LST:
;
UD$LIST	EQU	TRUE		;<== USE DISPATCH FOR IOLIST IF TRUE
				;(IF FALSE, THEN LPTOUT IS ASSUMED)
	IF UD$LIST
IOLIST:
	CALL DISPATCH
	DB	3		;USE IOBYTE BITS 7-6
	DB	CRTOUT-$	;00 - TTY: (CRT OUTPUT)
	DB	CRTOUT-$	;01 - CRT:	"
	DB	LPTOUT-$	;10 - LPT: (LINE PRINTER OUTPUT)
	DB	CRTOUT-$	;11 - UL1: (CRTSOLE OUTPUT)
	ENDIF

;********
;
;	PUNCH OUT - PUN:
;
UD$PUNCH EQU	TRUE		;<== USE DISPATCH FOR IOPUNCH IF TRUE
				;(IF FALSE, THEN PUNOUT IS ASSUMED)
	IF UD$PUNCH
IOPUNCH:
	CALL	DISPATCH
	DB	5		;USE IOBYTE BITS 5-4
	DB 	CRTOUT-$	;00 - TTY: (CRTSOLE OUTPUT)
	DB	PUNOUT-$	;01 - PTP: (HIGH SPEED PUNCH OUTPUT)
	DB	CRTOUT-$	;10 - UP1: (CRTSOLE OUTPUT)
	DB	CRTOUT-$	;11 - UP2:	"
	ENDIF

;********
;
;	READER IN - RDR:
;
UD$READER EQU	TRUE		;<== USE DISPATCH FOR IOREADER IF TRUE
				;(IF FALSE, THEN RDRIN IS ASSUMED)
	IF UD$READER
IOREADER:
	CALL	DISPATCH
	DB	7		;USE IOBYTE BITS 3-2
	DB	CRTIN-$		;00 - TTY: (CRT INPUT)
	DB	RDRIN-$		;01 - PTR: (HIGH SPEED READER INPUT)
	DB	CRTIN-$		;10 - UR1: (CRT INPUT)
	DB	CRTIN-$		;11 - UR2:	"
	ENDIF


;********************************************************
;	LIST CHARACTER IN C				*
;********************************************************

	IF NOT UD$LIST
IOLIST:				;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

LPTOUT:
	CALL	IOLISTST	;GET PRINTER STATUS
	JZ	LPTOUT		;LOOP IF NOT READY

	IF MPUBPAR
	MOV	A,C
	OUT	14H		;** SEND DATA 3 TIMES TO
	OUT	14H		;** TO ASSURE THAT
	OUT	14H		;** PRINTER SEES STROBE
	RET
	ENDIF

	IF MPUZPAR
	MOV	A,C
	OUT	PARAA		;SEND DATA TO LATCH
	MVI	A,08
	OUT	PARACTL		;RAISE STROBE
	INR	A
	OUT	PARACTL		;LOWER STROBE
	RET
	ENDIF

	IF SIO40B		;IF PRINTER ON SIO-2 TI810 PORTS 44 & 45
	IN	45H		;GET STATUS AGAIN
	ANI	80H		;CHECK FOR PRINTER READY ON RS232 PIN 20
	JZ	LPTOUT
	MOV	A,C
	CPI	13H		;DO NOT OUTPUT 13H TO SOME PRINTERS
	RZ
	OUT	44H
	RET
	ENDIF

;********************************************************
;	RETURN LIST STATUS (FF IF READY, ELSE 0)	*
;********************************************************

IOLISTST:
	IF MPUBPAR
	IN	14H
	ANI	1		;<A>=0 IF READY, ELSE <A>=1 
	ENDIF

	IF MPUZPAR
	IN	PARAB
	ANI	1		;<A>=0 IF READY, ELSE <A>=1 
	ENDIF

	IF SIO40B
	IN	45H
	DCR	A		;COMPLEMENT LOW BIT OF <A>
	ANI	1		;<A>=0 IF READY, ELSE <A>=1 
	ENDIF

	IF NOT (MPUBPAR+MPUZPAR+SIO40B)	;ie IF NO PRINTER
	XRA	A			;...THEN ALLWAYS READY
	ENDIF

	DCR	A		;<A> AS ADVERTISED
	RET

;********************************************************
;	CRT STATUS RETURNED IN A.			*
;							*
;	<A>=00	KEYBOARD CHARACTER NOT READY		*
;	<A>=FF	KEYBOARD CHARACTER READY		*
;********************************************************

	IF NOT UD$CONST
IOCONST:			;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

CRTSTAT:
	IN	CRTST		;STATUS PORT
	ANI	CRTRXR		;TEST RxRDY
CRTS1	RZ			;IF NOT READY
	MVI	A,0FFH		;ELSE...RETURN FF
	RET

;********************************************************
;	CRTIN RETURNS KEYBOARD CHARACTER IN <A>		*
;********************************************************

	IF NOT UD$CONIN
IOCONIN:			;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

CRTIN:
	CALL	CRTSTAT
	JZ	CRTIN		;GET RxRDY
	IN	CRTDATA		;GET CHAR
	ANI	7FH		;STRIP PARITY
	RET

;********************************************************
;	CRT SENDS THE CHARACTER IN <C> TO OUTPUT	*
;********************************************************

	IF NOT UD$CONOUT
IOCONOUT:			;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

CRTOUT:
	IN	CRTST		;GET STATUS
	ANI	CRTTXR		;TxRDY?
	JZ	CRTOUT		;REPEAT, NOT READY
	MOV	A,C		;CHAR TO ACCUM
	OUT	CRTDATA		;CHAR TO PORT
	RET

;********************************************************
;	PUNCH CHARACTER IN REGISTER <C>			*
;********************************************************

	IF NOT UD$PUNCH
IOPUNCH:			;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

PUNOUT:

	IF RDRPUN
	IN	RPST
	ANI	RPTXR
	JZ	PUNOUT		;IF RECIEVER NOT READY FOR NEXT BYTE
	MOV	A,C
	OUT	RPDATA		;DATA TO "PUNCH"
	RET
	ENDIF

;	NOTE: IF RDRPUN=FALSE WE USE RET FROM RDRIN

;********************************************************
;	READ CHARACTER INTO <A> FROM READER DEVICE	*
;********************************************************

	IF NOT UD$READER
IOREADER:			;DEFINE HERE IF NOT USING DISPATCH
	ENDIF

RDRIN:

	IF NOT RDRPUN
	MVI	A,1AH		;NO READER? RETURN ^Z AS EOF INDICATION
	RET
	ENDIF

	IF RDRPUN
	IN	RPST
	ANI	RPRXR
	JZ	RDRIN		;IF NO DATA FROM "READER" AS YET
	IN	RPDATA		;ACCEPT BYTE FROM READER
	RET
	ENDIF

;********************************************************
;	DISPATCH TO ACCESS CONSOLE, PRINTER PUNCH, ETC	*
;							*
;	(FOR MAX RANGE ON ONE-BYTE ADDRESSES IT IS	*
;	 BEST TO LEAVE THIS ROUTINE AFTER THE END	*
;	 OF THE LAST CRT, PRINTER, PUNCH OR WHATEVER	*
;	 ACCESS SUBROUTINE.)				*
;********************************************************

       IF UD$CONST OR UD$CONIN OR UD$CONOUT OR UD$LIST OR UD$PUNCH OR UD$READER
DISPATCH:
	XTHL			;SAVE CALLER'S <HL>, GET TABLE ADDR
	MOV	D,M		;SHIFT COUNT
	INX	H		;POINT TABLE
	LDA 	IOBYTE		;GET IO ASSIGNMENTS BYTE
DSHFT:	RLC
	DCR	D
	JNZ	DSHFT		;SHIFT TO POSITION BITS
	RRC
	ANI	03H		;MASK BITS
	MOV	E,A		;D ALREADY CLEAR
	DAD	D		;INDEX INTO TABLE
	MOV	E,M		;FETCH PROPER ADDRESS BYTE
	DAD	D		;ADD BACK THE "-$" OR DISPATCH ADDRESS TO <HL>
	XTHL			;PUT DISPATCH ADDRESS, RESTORE CALLER'S <HL>
	RET			;GO TO ROUTINE
	ENDIF

;********************************************************
;	WBOOT LOADS CP/M FROM THE SYSTEM TRACKS		*
;********************************************************

;	WE NEED TO RELOAD CCP BECAUSE SOME TRANSISANT PROGRAMS
;	USE CCP'S SPACE AS PART THIER SCRATCH STORAGE.  BUT WE ALSO
;	NEED TO BE CAREFULL BECAUSE SELF-RELOCATING PROGRAMS LIKE
;	DDT/SID, DESPOOL AND XSUB RUN JUST BELOW CCP.  DESPOOL
;	AND XSUB NEED TO SURVIVE A WARM BOOT.
;
;	WE TELL THE OMNIDISK CONTROLLER THAT WE	WANT TO LOAD THE
;	BOOTSTRAP PLUS ALL OF CCP ROUNDED UP TO A LOGICAL SECTOR.
;	THE FIRST 40H BYTES OF WHAT WE READ IS OUR BOOTSTRAP WHICH
;	WE MUST NOT LOAD ON TOP OF A SELF-RELOCATING PROGRAM.
;
;	ALL WOULD BE EASY IF ERROR RECOVERY WERE NOT REQUIRED.
;
;	WE DO OUR NORMAL READ WITH GET-GENERAL-STATUS.  THE FIRST
;	BYTE RETURNED IS EITHER THE FIRST BYTE OF THE BOOTSTRAP OR THE
;	GENERAL STATUS ANNOUNCING THE FAILURE.  IF FAILURE, WE LOOP
;	BACK AND TRY AGAIN, ELSE WE KNOW THAT AT LEAST THE REST OF
;	THE FIRST SECTOR IS WAITING TO BE DELIVERED.  NEXT WE READ AND
;	TRASH THE OTHER 3FH BYTES OF THE BOOTSTRAP AND THEN CALL GETDAT
;	TO RESTORE CCP.  WHEN GETDAT RETURNS, WE CHECK GENERAL STATUS.
;	IF AN ERROR IS INDICATED WE GO BACK AND RETRY THE OPERATION.
;
;	THERE ARE NO MESSAGES IN THE RETRY LOOP.  THERE IS NO WAY TO
;	ABORT ITS OPERATION SHORT OF HITTING RESET.
;
WBOOT0	STA	CDISK		;(FROM BIOS ERROR RECOVERY) SET FOR "A:" DISK
WBOOT:				;MAIN ENTRY TO THIS SECTION
	LXI	SP,TPA		;USE SPACE BELOW TPA FOR STACK
	CALL	CMDLIST
	DB	5		;LENGTH OF LIST
	DB	OC$UNIT,0	;SELECT A: DISK
	DB	OC$BOOT
	DB	(BDOS-BSORG+127)/128	;NUMBER OF (LOGICAL) SECTORS TO LOAD
	DB	OC$GENS		;GENERAL STATUS REQUEST FOR READ END
	CALL	INCHAR		;THIS IS EITHER 1ST OF BOOTSTRAP OR GENSTAT
	IN	OMNISTAT
	ORA	A		;WHAT DID INCHAR JUST DELIVER?
	JP	WBOOT		;IF WE GOT GENSTAT THEN ERROR.	GO RETRY.
	MVI	C,LENBSTRAP-1
WBOOT1:	CALL	INCHAR		;READ AND TRASH BOOTSTRAP PART OF 1ST SECTOR
	DCR	C
	JNZ	WBOOT1		;IF MORE BOOTSTRAP TO TRASH
	LXI	H,CCP
	CALL	GETDAT
	ORA	A		;GENERAL STATUS
	JNZ	WBOOT		;IF ERROR RELOADING CCP WE GO TRY AGAIN
;	...			;FALL INTO GOCPM

;********************************************************
;	SET PARAMETERS AND GO TO CP/M			* 		
;********************************************************

GOCPM:
	MVI	A,(JMP)
	STA	0		;JMP TO WBOOT
	LXI	H,WBOOTE	;WBOOT ENTRY POINT
	SHLD	1		;JUMP ADDR AT 0

	STA	5		;JMP TO BDOS
	LXI	H,BDOS		;BDOS ENTRY POINT
	SHLD	6		;JUMP ADDR AT 5

	LXI	B,80H		;** SETUP DEFAULT
	CALL	SETDMA		;** DMA ADDRESS

	IF FRONTP
	XRA	A
	OUT	0FFH		;0 FRONT PANEL
	ENDIF

;	CLEAN UP AND GO TO CCP

	EI			;ENABLE INTERRUPTS
	LDA	CDISK		;CURRENT DISK #
	MOV	C,A		;SEND TO CCP
	JMP	CCP

;********************************************************
;	DISK I/O DRIVERS. STORE	THE PARAMETERS		*
;	AWAY FOR THE READ AND WRITE SUBROUTINES		*
;********************************************************

;********************************************************
;	SELECT DISK GIVEN BY <C>			*
;********************************************************

SELDSK:
	LXI	H,0		;USED FOR <H>=0 AND IF SELECT ERROR
	MOV	A,C
	CPI	NDISKS		;MUST BE BETWEEN 0 AND NDISKS-1
	RNC			;IF INVALID DISK NUMBER

;	COMPUTE PROPER DISK PARAMETER HEADER ADDR

	CALL	ONELIST
	DB	OC$UNIT		;OMNI COMMAND: SELECT LOGICAL UNIT
	CALL	CMDINC		;UNIT ADDRESS TO OMNI
	MOV	L,C		;<HL> = UNIT NUMBER (A:=0, B:=1,,, P:=0FH)
	DAD	H		;*2
	DAD	H		;*4
	DAD	H		;*8
	DAD	H		;*16 (SIZE OF EACH HEADER)
	LXI	B,DPHBASE
	DAD	B		;<HL> = DPH ADDRESS
	MOV	A,E
	RAR
	RC			;IF DRIVE WAS LOGGED
;
;	DRIVE NEVER LOGGED -- CALL DRIVE SELECT
;
	SHLD	DPHADRS		;SAVE DPH ADDRESS IN CASE WE NEED TO RETRY
	CALL	SRETA		;SET RETRY ADDRESS FOR CKERR
	LXI	H,$-$
DPHADRS EQU	$-2
	PUSH	H		;DPH ADDRESS
	CALL	SELDRV		;DO THE GETDPB STUFF
	POP	H		;DPH ADDRESS
	JMP	CKERR		;CHECK ERROR, GIVE ERROR MSG ETC

;********************************************************
;	HOME THE HEAD TO TRACK 0			*
;********************************************************

HOME:
	LXI	B,0
;	...			;FALL INTO SETTRK

;********************************************************
;	SET TRACK GIVEN IN <BC>				*
;********************************************************

SETTRK:
	CALL	ONELIST
	DB	OC$TRAK		;OMNI COMMAND: SELECT TRACK (CYLINDER)
CMDINCB	CALL	CMDINC		;LOW BITS OF TRACK NUMBER TO OMNI
	MOV	A,B
	JMP	SENDCMD		;HIGH BITS OF TRACK NUMBER TO OMNI

;********************************************************
;	SET SECTOR (RECORD NUMBER) GIVEN BY <C>		*
;********************************************************

SETSEC:
	CALL	ONELIST
	DB	OC$RECD		;OMNI COMMAND: SELECT SECTOR NUMBER
CMDINC	MOV	A,C		;THE SECTOR NUMBER
	JMP	SENDCMD

;********************************************************
;	SECTOR LOGICAL TO PHYSICAL TRANSLATION		*
;							*
;	TRANSLATE DELAYED UNTIL I/O DONE IN OMNIDISK	*
;							*
;	NOTE: THIS 3-BYTE ROUTINE REPLACES ITS JMP	*
;	      IN THE BIOS JMP VECTOR			*
;********************************************************
;SECTRAN:
;	TRANSLATE DELAYED UNTIL READ DONE IN CONTROLLER
;	RETURN WITH SECTOR FROM BC IN HL
;	MOV	L,C
;	MOV	H,B
;	RET

;********************************************************
;	SET DMA GIVEN BY <BC> FOR READ/WRITE BUFF	*
;********************************************************

SETDMA:	
	IF NOT DMA
	MOV	L,C		;LOW ADDR BYTE
	MOV	H,B		;HIGH ADDR BYTE
	SHLD	DMAADR		;DMA ADDR
	RET
	ENDIF

	IF DMA
	CALL	ONELIST
	DB	OC$DADR		;OMNI COMMAND: SET DMA ADDRESS
	CALL	CMDINCB		;SEND LOW AND MID DMA ADDRESS
	CALL	ONELIST
	DB	DMAEXT		;DMA ADDRESS EXTENDED
	RET
	ENDIF

;********************************************************
;	READ A LOGICAL SECTOR				*
;********************************************************

READ:
	CALL	SRETA		;SET RETRY ADDRESS (USED IF OMNI I/O ERROR)
	CALL	CMDLIST
	DB	2		;LENGTH OF LIST
	DB	OC$READ,OC$GENS	;OMNI COMMANDS: READ AND GET GENERAL STATUS

	IF NOT DMA
	LXI	H,$-$
DMAADR	EQU	$-2
	CALL	GETDAT		;GET THE DATA, RETURN GENERAL STATUS
	JMP	CKERR
	ENDIF

	IF DMA
	JMP	WRITE2		;DMA: WAIT FOR AND THEN CHECK GENERAL STATUS
	ENDIF

;********************************************************
;	WRITE A LOGICAL SECTOR				*
;********************************************************
;	WRITE THE SELECTED CP/M SECTOR
;		AT ENTRY C = 0 - FOR NORMAL SECTOR WRITE
;			     1 - WRITE DIRECTORY SECTOR
;			     2 - WRITE SECTOR OF A NEW DATA BLOCK
;
SLOW$WRITE EQU	FALSE		;<== SEE COMMENTS BELOW
;
;	IF YOU ARE VERY TIGHT FOR SPACE IN A NON-DMA SYSTEM
;	CHANGING THE ABOVE EQUATE WILL SAVE YOU 5 BYTES AT THE
;	EXPENSE OF A CALL/RET AND PUSH/POP FOR EACH BYTE OF
;	EACH SECTOR WRITTEN.
;


WRITE:
	MOV	A,C
	STA	WRITEA		;SAVE WRITE MODIFIER
	CALL	SRETA		;SET RETRY ADDRESS (USED IF OMNI I/O ERROR)
	CALL	CMDLIST
	DB	2		;LENGTH OF LIST
	DB	OC$WRIT		;OMNI COMMAND: WRITE TO DISK
WRITEA	DB	$-$		;WRITE MODIFIER TO OMNI

	IF NOT DMA AND NOT SLOW$WRITE
	CALL	INCHAR		;GET GEN STATUS BEFORE WRITE DATA XFER
	ORA	A
	JNZ	CKERR		;IF ERROR IN READ-BEFORE-WRITE
	MVI	C,128
	LHLD	DMAADR
WRITE1	IN	OMNISTAT
	ADD	A
	JC	WRITE1		;IF NOT READY FOR NEXT BYTE
	MOV	A,M
	OUT	OMNIDATA	;WRITE DATA TO OMNI
	INX	H
	DCR	C
	JNZ	WRITE1		;IF MORE DATA TO SEND
	XRA	A		;FAKE GOOD STATUS FOR CKERR
	ENDIF

	IF NOT DMA AND SLOW$WRITE
	CALL	INCHAR		;GET GEN STATUS BEFORE WRITE DATA XFER
	ORA	A
	JNZ	CKERR		;IF ERROR IN READ-BEFORE-WRITE
	MVI	C,128
	LHLD	DMAADR
WRITE1	MOV	A,M
	CALL	SENDCMD		;WRITE DATA TO OMNI
	INX	H
	DCR	C
	JNZ	WRITE1		;IF MORE DATA TO SEND
	XRA	A		;FAKE GOOD STATUS FOR CKERR
	ENDIF

	IF DMA
WRITE2	CALL	INCHAR		;GET GENERAL STATUS AFTER DATA XFER
	ENDIF

;	JMP	CKERR		;(FALL INTO CKERR)

;********************************************************
;	SUBROUTINE FOR UNEXPECTED DRIVE ERRORS		*
;********************************************************

CKERR:	ORA	A
	RZ			;IF NO ERROR
	CALL	ONELIST
	DB	OC$EXTS		;OMNI COMMAND: GET EXTENDED STATUS
;				;(THIS IS THE ONLY WAY TO ZERO GENSTAT)
	LXI	H,DERRM1
	CALL	OUTM		;OUT MESSAGE = "DISK I/O ERROR -"
	MVI	B,9		;LENGTH OF EXTENDED STATUS LIST
CKERR1	MVI	C,' '
	CALL	IOCONOUT
	CALL	INCHAR		;GET EXTENDED STATUS BYTE FROM OMNI
	CALL	HEXOUT		;SEND TO CONSOLE
	DCR	B
	JNZ	CKERR1		;IF NO MORE EXTENDED STATUS

;	LXI	H,DERRM2	;<HL> POINT TO DERRM2 WITHOUT THIS INSTRUCTION
	CALL	OUTM		;OUT MESSAGE = "^C ABORT etc..."
	CALL	IOCONIN		;WAIT FOR RESPONSE FROM USER
	LXI	H,0		;FOR "IGNORE" EXIT WHEN USED FROM SELDSK
	CPI	0DH
	RZ			;IF cr THEN RTN TO BDOS WITH <A> NON-ZERO
	SUI	'C'-40H
	JZ	WBOOT0		;IF ^C WE ABORT CHANGING LOGGED DISK TO "A:"
	CPI	1BH-('C'-40H)
	MVI	A,OC$IERR
	CZ	SENDCMD		;IF ESC HIT TRY TO IGNORE ERROR
	JMP	$-$		;ELSE...RETRY FAILED OPERATION
RETRY$ADDRESS EQU $-2

DERRM1
	IF VIOX
	DB	1FH		;CRLF ON VIOX
	ENDIF
	IF NOT VIOX
	DB	CR,LF
	ENDIF
	DB	'DISK I/O ERROR -',0
DERRM2
	IF VIOX
	DB	1FH		;CRLF ON VIOX
	ENDIF
	IF NOT VIOX
	DB	CR,LF
	ENDIF
	DB	'^C ABORT, cr IGNORE, ELSE RETRY',0

OUTM:	MOV	A,M
	INX	H
	ORA	A
	RZ			;IF AT END OF MESSAGE
	CALL	ACONOUT		;SEND TO CONSOLE
	JMP	OUTM		;REPEAT UNTIL DONE

HEXOUT:
	PUSH	PSW
	RAR ! RAR ! RAR ! RAR	;POSITION HIGH ORDER NIBBLE...
	CALL	HEXOUT1		;...SEND TO CONSOLE
	POP	PSW		;NOW LOW NIBBLE
HEXOUT1 ANI	0FH		;ISOLATE NIBBLE
	SUI	10
	JM	HEXOUT2		;IF CONVERTING 0-9
	ADI	7		;ELSE CONVERTING A-F
HEXOUT2	ADI	10+'0'		;NIBBLE NOW CONVERTED TO ASCII
ACONOUT	MOV	C,A
	JMP	IOCONOUT	;SEND TO CONSOLE AND RETURN TO OUR CALLER

;********************************************************
;	SET RETRY ADDRESS FOR OMNI I/O ERRORS		*
;********************************************************

SRETA	XTHL
	SHLD	RETRY$ADDRESS
	XTHL
	RET

;********************************************************
;	SELECT A NEW DRIVE				*
;********************************************************
;
;	NOTE USE OF TRACK 4 IN GETDPB.  ONE MIGHT THINK THAT TRACK
;	TWO (DIRECTORY) WOULD BE BETTER.  TRACK 4 WAS SELECTED
;	BECAUSE (1) WE DO NOT WANT THE DIRECTORY TRACK BECAUSE
;	IT IS THE MOST LIKELY TO BE ZAPPED BY A SYSTEM PROBLEM,
;	(2) WE DO NOT WANT ANY SYSTEM TRACKS BECAUSE THEY MIGHT
;	BE FORMATTED AT SOME DENSITY OTHER THAN THE REST OF THE
;	DISK AND (3) THE SYSTEM TAKES 3 TRACKS ON SOME 5" FLOPPIES.

SELDRV:
	LXI	D,10		;DPH OFFSET TO DPB
	DAD	D
	MOV	E,M		;LOW DPB
	INX	H
	MOV	H,M		;HIGH DBP
	MOV	L,E		;<HL> = DPB ADDRESS
	CALL	CMDLIST
	DB	5		;LENGTH OF LIST
	DB	OC$TRAK		;OMNI COMMAND: SELECT TRACK (SEEK)
	DW	4		;GO TO TRACK 4 FOR GETDPB FUNCTION
	DB	OC$GDPB		;OMNI COMMAND: GET DPB
	DB	OC$GENS		;OMNI COMMAND: GET GENERAL STATUS
;				;	       (USED TO END GETDAT LOOP)
;	... FALL INTO GETDAT

;********************************************************
;	SUBROUTINE FOR BLOCK READ			*
;							*
;	NOTE:	THIS SUBROUTINE READS DATA UNTIL	*
;		THE OMNI CONTROLLER ACCEPTS THE		*
;		GENERAL STATUS COMMAND			*
;********************************************************

GETDAT:	IN	OMNISTAT
	RRC
	JNC	GETDAT		;IF NOTHING TO GET FROM OMNI
	ANI	40H		;(WHAT DO WE HAVE HERE: DATA -OR- GEN STATUS?)
	IN	OMNIDATA	;TAKE IT, WHATEVER IT IS
	RZ			;IF IT IS GENERAL STATUS, THEN RETURN
	MOV	M,A		;ELSE...PUT INTO BUFFER
	INX	H
	JMP	GETDAT		;KEEP ON KEEPING ON

;********************************************************
;	SUBROUTINE TO SEND CONSTANT BYTE TO OMNIDISK	*
;********************************************************

ONELIST:
	XTHL
	MOV	A,M
	INX	H
	XTHL
;	...			FALL INTO SENDCMD
;	...
;********************************************************
;	SUBROUTINE TO SEND COMMAND TO DISK CONTROLLER	*
;********************************************************

SENDCMD:
	PUSH	PSW		;BYTE TO SEND TO OMNI
SENDCMD1:
	IN	OMNISTAT
	RAL
	JC	SENDCMD1	;IF OMNI NOT READY TO TAKE BYTE
	POP	PSW
	OUT	OMNIDATA
	RET

;****************************************************************
;	SUBROUTINE TO ACCEPT ONE BYTE FROM DISK CONTROLLER	*
;****************************************************************

INCHAR:
	IN	OMNISTAT
	RAR
	JNC	INCHAR		;IF OMNI HAS NOT YET SENT REPLY
	IN	OMNIDATA	;ACCEPT REPLY
	RET

;********************************************************
;	SUBROUTINE TO ISSUE COMMAND LIST		*
;********************************************************

CMDLIST:
	XTHL
	MOV	C,M		;FETCH LENGTH OF LIST
	INX	H
CMDLIST1:
	MOV	A,M		;NEXT BYTE TO SEND
	INX	H
	CALL	SENDCMD		;BYTE TO CONTROLLER
	DCR	C
	JNZ	CMDLIST1	;IF MORE COMMANDS TO SEND
	XTHL
	RET

;********************************************************
;	DISK PARAMETER HEADER TABLES			*
;********************************************************
;
;	PLEASE NOTE SEVERAL THING ABOUT THIS TABLE:
;
;	(1) THE "IF (NDISKS+99)/100" LOOKS STRANGE, BUT HAD TO BE
;	    MORE COMPLEX THAN "NDISKS/nn" BECAUSE OF AN UNDOCUMENTED
;	    FEATURE (THIS SOFTWARE WRITER CALLS IT A BUG) THAT
;	    MAKES "IF EXP" ACT AS IT WERE WRITTEN "IF EXP AND 1".
;
;	(2) THE "DW DEV$x" IN PLACE OF THE SKEW TABLE ADDRESS
;	    IS CLEARLY NOT SKEW TABLE ADDRESS.  IT IS USED BY
;	    BY THE LU-CHANGING UTILITY AND PERHAPS SOMEDAY BY
;	    COLD START WITHIN THE BIOS.

DPHBASE:

	IF (NDISKS+99)/100		;DPH FOR DRIVE 0 ( A: )
	DW	DEV$A,0,0,0,DIRBUF
	DW	TDPB$A,TCKV$A,TALV$A
	ENDIF

	IF (NDISKS+99)/101		;DPH FOR DRIVE 1 ( B: )
	DW	DEV$B,0,0,0,DIRBUF
	DW	TDPB$B,TCKV$B,TALV$B
	ENDIF

	IF (NDISKS+99)/102		;DPH FOR DRIVE 2 ( C: )
	DW	DEV$C,0,0,0,DIRBUF
	DW	TDPB$C,TCKV$C,TALV$C
	ENDIF

	IF (NDISKS+99)/103		;DPH FOR DRIVE 3 ( D: )
	DW	DEV$D,0,0,0,DIRBUF
	DW	TDPB$D,TCKV$D,TALV$D
	ENDIF

	IF (NDISKS+99)/104		;DPH FOR DRIVE 4 ( E: )
	DW	DEV$E,0,0,0,DIRBUF
	DW	TDPB$E,TCKV$E,TALV$E
	ENDIF

	IF (NDISKS+99)/105		;DPH FOR DRIVE 5 ( F: )
	DW	DEV$F,0,0,0,DIRBUF
	DW	TDPB$F,TCKV$F,TALV$F
	ENDIF

	IF (NDISKS+99)/106		;DPH FOR DRIVE 6 ( G: )
	DW	DEV$G,0,0,0,DIRBUF
	DW	TDPB$G,TCKV$G,TALV$G
	ENDIF

	IF (NDISKS+99)/107		;DPH FOR DRIVE 7 ( H: )
	DW	DEV$H,0,0,0,DIRBUF
	DW	TDPB$H,TCKV$H,TALV$H
	ENDIF

	IF (NDISKS+99)/108		;DPH FOR DRIVE 8 ( I: )
	DW	DEV$I,0,0,0,DIRBUF
	DW	TDPB$I,TCKV$I,TALV$I
	ENDIF

	IF (NDISKS+99)/109		;DPH FOR DRIVE 9 ( J: )
	DW	DEV$J,0,0,0,DIRBUF
	DW	TDPB$J,TCKV$J,TALV$J
	ENDIF

	IF (NDISKS+99)/110		;DPH FOR DRIVE 10 ( K: )
	DW	DEV$K,0,0,0,DIRBUF
	DW	TDPB$K,TCKV$K,TALV$K
	ENDIF

	IF (NDISKS+99)/111		;DPH FOR DRIVE 11 ( L: )
	DW	DEV$L,0,0,0,DIRBUF
	DW	TDPB$L,TCKV$L,TALV$L
	ENDIF

	IF (NDISKS+99)/112		;DPH FOR DRIVE 12 ( M: )
	DW	DEV$M,0,0,0,DIRBUF
	DW	TDPB$M,TCKV$M,TALV$M
	ENDIF

	IF (NDISKS+99)/113		;DPH FOR DRIVE 13 ( N: )
	DW	DEV$N,0,0,0,DIRBUF
	DW	TDPB$N,TCKV$N,TALV$N
	ENDIF

	IF (NDISKS+99)/114		;DPH FOR DRIVE 14 ( O: )
	DW	DEV$O,0,0,0,DIRBUF
	DW	TDPB$O,TCKV$O,TALV$O
	ENDIF

	IF (NDISKS+99)/115		;DPH FOR DRIVE 15 ( P: )
	DW	DEV$P,0,0,0,DIRBUF
	DW	TDPB$P,TCKV$P,TALV$P
	ENDIF
DPHEND:

;--------------------------------------------------------
;-	THE FOLLOWING CODE RUNS RIGHT AFTER THE SYSTEM	-
;-	IS LOADED.  NO CODE IN THIS AREA CAN BE USED	-
;-	AGAIN BECAUSE VARIOUS BUFFERS ARE ALLOCATED	-
;-	PAST THIS POINT.				-
;--------------------------------------------------------

DSORG:				;ORG FOR UN-INIT "DS" BUFFERS

	IF NOT ASMDPH	;ie IF WE ARE USING THE DPH BUILDER
	ORG	DPHBASE	;THEN ASSEMBLE THE COLD START
	ENDIF		;CODE ON TOP OF THE DPH AREA

;********************************************************
;	SIGN ON MESSAGE DURING COLD BOOT		*
;********************************************************

SIGNON:
	IF VIOX
	DB	1FH		;CRLF ON VIOX
	ENDIF
	IF NOT VIOX
	DB	CR,LF
	ENDIF
	DB	'COPYRIGHT (c) 1983 BY '
	DB	'FULCRUM COMP. PRODS.  (707) 433-0202',LF
;	DB 	'W/W COMPONENTS INC.  (408) 295-7171',LF
	IF VIOX
	DB	1FH		;CRLF ON VIOX
	ENDIF
	IF NOT VIOX
	DB	CR,LF
	ENDIF
	DB	'0'+MSIZE/10	;CP/M MEMORY SIZE
	DB	'0'+(MSIZE MOD 10)
	DB	'k CP/M vers '	;CP/M VERSION NUMBER
	DB 	CPMREV/10+'0'
	DB 	'.'
	DB	(CPMREV MOD 10)+'0'
	IF VIOX
	DB	1FH		;CRLF ON VIOX
	ENDIF
	IF NOT VIOX
	DB	CR,LF
	ENDIF
	IF DMA
	DB	'DMA '
	ENDIF
	DB	'BIOS rev '
	DB	REVNUM/10+'0','.' ;BIOS REVISION NUMBER
	DB	REVNUM MOD 10+'0'
	DB	' 29 DEC 84'
;	DB	' TIME: 1920'
	DB	' -- WA 8BC 5D'		;HELP PETE KEEP TRACK OF SYSTEM TYPE
	IF VIOX
	DB	1FH			;CRLF ON VIOX
	ENDIF
	IF NOT VIOX
	DB	CR,LF
	ENDIF

	IF VIOXTIME
	DB	1BH,'>'		;LEADIN FOR VIOX SET CLOCK FUNCTION
	ENDIF

	DB	0

;********************************************************
;	COLD BOOT INITIALIZES VARIABLES IN PAGE ZERO,	*
;	SETS THE OMNIDISK CONTROLLER FOR THE DESIRED	*
;	DEVICE SET, DOES WHATEVER HARDWARE INIT MAY BE	*
;	REQUIRED AND PRINTS THE SIGN-ON MESSAGE.	*
;							*
; REMEMBER, THIS AREA IS OVERLAYED WITH VARIOUS BUFFERS	*
;							*
;********************************************************

CBOOT:
	LXI	SP,TPA		;MEM BELOW TPA FOR STACK
	LXI	H,0094H		;00 (A:) FOR CDISK, 94 FOR IOBYTE
	SHLD	IOBYTE		;IOBYTE IS LOC 3, CDISK IS LOC 4
	IN	CRTDATA		;CLEAR POWER ON JUNK
;
;	UNDEFINE ALL LOGICAL-TO-PHYSICAL MAPPING WITHIN CONTROLLER.
;
	IF ((NDISKS+99)/111) XOR 1	;ie IF NDISKS .LE. 11
	LXI	H,CB2
CB1	CALL	CMDLIST
	DB	3		;LENGTH OF LIST
	DB	OC$DLDS		;OMNI COMMAND: DEFINE LOGICAL DEVICE SET
CB2	DB	0FH		;LOGICAL UNIT...
	DB	0		;...SET TO UNDEFINED
	DCR	M		;NEXT LOGICAL UNIT <M>=CB2
	JP	CB1		;IF WE NEED TO ZAP MORE UNITS
	ENDIF
;
	CALL	CMDLIST
	DB	CBLEND-$-1	;LENGTH OF LIST
	DB	OC$MODE		;OMNI COMMAND: SET DMA OR NON-DMA MODE

	IF NOT DMA
	DB	DMAPRI		;NOTE TO USERS WHERE DMA KILLS YOUR SYSTEM:
					;BIOS DOES NOT CAUSE ANY DMA
	ENDIF				;UNLESS MEMORY DISK IS USED.

	IF DMA
	DB	DMAPRI+80H	;BIOS USES DMA FOR READ/WRITE
	ENDIF
;
;	DEFINE FLOPPY DISK PHYSICAL PARAMETERS
;
	DB	OC$SFDP
	DB	WDELAY,LDELAY		;DELAYS BEFORE WRITE & UNLOADING HEADS
	DB	STEP8,STEP5		;FLOPPY STEP RATE
	DB	LOAD8,LOAD5		;FLOPPY HEAD LOAD TIME
	DB	SETL8,SETL5		;HEAD SETTLE TIME (AFTER FD SEEK)
;
;	DEFINE LOGICAL-TO-PHYSICAL MAPPINGS USED BY CURRENT SYSTEM
;	
	IF (NDISKS+99)/100		;DRIVE 0 ( A: )
	DB	OC$DLDS,00H,DEV$A	;DEFINE A:
	ENDIF
	IF (NDISKS+99)/101		;DRIVE 1 ( B: )
	DB	OC$DLDS,01H,DEV$B	;DEFINE B:
	ENDIF
	IF (NDISKS+99)/102		;DRIVE 2 ( C: )
	DB	OC$DLDS,02H,DEV$C	;DEFINE C:
	ENDIF
	IF (NDISKS+99)/103		;DRIVE 3 ( D: )
	DB	OC$DLDS,03H,DEV$D	;DEFINE D:
	ENDIF
	IF (NDISKS+99)/104		;DRIVE 4 ( E: )
	DB	OC$DLDS,04H,DEV$E	;DEFINE E:
	ENDIF
	IF (NDISKS+99)/105		;DRIVE 5 ( F: )
	DB	OC$DLDS,05H,DEV$F	;DEFINE F:
	ENDIF
	IF (NDISKS+99)/106		;DRIVE 6 ( G: )
	DB	OC$DLDS,06H,DEV$G	;DEFINE G:
	ENDIF
	IF (NDISKS+99)/107		;DRIVE 7 ( H: )
	DB	OC$DLDS,07H,DEV$H	;DEFINE H:
	ENDIF
	IF (NDISKS+99)/108		;DRIVE 8 ( I: )
	DB	OC$DLDS,08H,DEV$I	;DEFINE I:
	ENDIF
	IF (NDISKS+99)/109		;DRIVE 9 ( J: )
	DB	OC$DLDS,09H,DEV$J	;DEFINE J:
	ENDIF
	IF (NDISKS+99)/110		;DRIVE 10 ( K: )
	DB	OC$DLDS,0AH,DEV$K	;DEFINE K:
	ENDIF

	IF (NDISKS+99)/111		;DRIVES 11-15( L:-P: )
	DB	OC$DLDS,0BH,DEV$L	;DEFINE L:
	DB	OC$DLDS,0CH,DEV$M	;DEFINE M:
	DB	OC$DLDS,0DH,DEV$N	;DEFINE N:
	DB	OC$DLDS,0EH,DEV$O	;DEFINE O:
	DB	OC$DLDS,0FH,DEV$P	;DEFINE P:
	ENDIF
;
;	DEFINE HARD DISK STUFF IF WE ARE USING IT
;
	IF HD$USE
	DB	OC$HDPR		;OMNI COMMAND: SET HARD DISK PARAMETERS
	DB	HD$NHDS		;HARD DISK NUMBER OF HEADS
	DB	HD$PCMP		;PRE-COMP (FOR WRITES ABOVE *PHYSICAL* CYL)
	DB	HD$STEP		;HARD DISK STEP RATE (0=COMPILED SEEK)
	DB	HD$CTLR		;CONTROLLER TYPE
	ENDIF
;
;	DEFINE HARD DISK TABLES FOR FIRST HARD DISK
;
	IF HD$USE0
	DB	OC$HDTB		;OMNI COMMAND: SET HARD DISK TABLE
	DB	HDLU$0		;LOGICAL UNIT FOR FIRST LOGICAL HARD DISK
	DB	HD$SEL0		;PHYS HD SEL CODE (0, 8, 10H, 18H ONLY)
	DW	HD$BASE0	;PHYS TRK OFFSET OF FOLLOWING OS BLOCK
				;DO NOT CONFUSE WITH CP/M OFFSET IN DPB
	DB	15		;LENGTH OF FOLLOWING OS BLOCK (DPB FOR CP/M)
	DW	64		;LOGICAL SECTORS PER TRACK
	DB	5,31		;4K ALLOCATION SIZE
	DB	1		;>255 ALLOCATION UNITS (JUST OVER 1MEG)
	DW	HD$SIZE0*2-1	;MAX ALLOC UNIT NUMBER (2 ALLOC/TRACK)
	DW	511		;<== 512 DIRECTORY ENTRIES
	DW	00F0H		;<== 4 ALLOCATION UNITS FOR DIRECTORY
	DW	0		;NO DIRECTORY CHECK VECTOR
	DW	2		;SPACE FOR 2 SYSTEM TRACKS
	ENDIF
;
; NOW THE SECOND LOGICAL HARD DISK
;
	IF HD$USE1
	DB	OC$HDTB		;OMNI COMMAND: SET HARD DISK TABLE
	DB	HDLU$1		;LOGICAL UNIT FOR SECOND LOGICAL HARD DISK
	DB	HD$SEL1		;PHYS HD SEL CODE (0, 8, 10H, 18H ONLY)
	DW	HD$BASE1	;PHYS TRK OFFSET OF FOLLOWING OS BLOCK
				;DO NOT CONFUSE WITH CP/M OFFSET IN DPB
	DB	15		;LENGTH OF FOLLOWING OS BLOCK (DPB FOR CP/M)
	DW	64		;LOGICAL SECTORS PER TRACK
	DB	5,31		;4K ALLOCATION SIZE
	DB	1		;>255 ALLOCATION UNITS (JUST OVER 1MEG)
	DW	HD$SIZE1*2-1	;MAX ALLOC UNIT NUMBER (2 ALLOC/TRACK)
	DW	1023		;<== 1024 DIRECTORY ENTRIES
	DW	00FFH		;<== 8 ALLOCATION UNITS FOR DIRECTORY
	DW	0		;NO DIRECTORY CHECK VECTOR
	DW	2		;SPACE FOR 2 SYSTEM TRACKS
	ENDIF
;
; NOW THE THIRD LOGICAL HARD DISK
;
	IF HD$USE2
	DB	OC$HDTB		;OMNI COMMAND: SET HARD DISK TABLE
	DB	HDLU$2		;LOGICAL UNIT FOR THIRD LOGICAL HARD DISK
	DB	HD$SEL2		;PHYS HD SEL CODE (0, 8, 10H, 18H ONLY)
	DW	HD$BASE2	;PHYS TRK OFFSET OF FOLLOWING OS BLOCK
				;DO NOT CONFUSE WITH CP/M OFFSET IN DPB
	DB	15		;LENGTH OF FOLLOWING OS BLOCK (DPB FOR CP/M)
	DW	64		;LOGICAL SECTORS PER TRACK
	DB	5,31		;4K ALLOCATION SIZE
	DB	1		;>255 ALLOCATION UNITS (JUST OVER 1MEG)
	DW	HD$SIZE2*2-1	;MAX ALLOC UNIT NUMBER (2 ALLOC/TRACK)
	DW	511		;<== 512 DIRECTORY ENTRIES
	DW	00F0H		;<== 4 ALLOCATION UNITS FOR DIRECTORY
	DW	0		;NO DIRECTORY CHECK VECTOR
	DW	2		;SPACE FOR 2 SYSTEM TRACKS
	ENDIF
;
; NOW THE FOURTH LOGICAL HARD DISK
;
	IF HD$USE3
	DB	OC$HDTB		;OMNI COMMAND: SET HARD DISK TABLE
	DB	HDLU$3		;LOGICAL UNIT FOR FOURTH LOGICAL HARD DISK
	DB	HD$SEL3		;PHYS HD SEL CODE (0, 8, 10H, 18H ONLY)
	DW	HD$BASE3	;PHYS TRK OFFSET OF FOLLOWING OS BLOCK
				;DO NOT CONFUSE WITH CP/M OFFSET IN DPB
	DB	15		;LENGTH OF FOLLOWING OS BLOCK (DPB FOR CP/M)
	DW	64		;LOGICAL SECTORS PER TRACK
	DB	5,31		;4K ALLOCATION SIZE
	DB	1		;>255 ALLOCATION UNITS (JUST OVER 1MEG)
	DW	HD$SIZE3*2-1	;MAX ALLOC UNIT NUMBER (2 ALLOC/TRACK)
	DW	511		;<== 512 DIRECTORY ENTRIES
	DW	00F0H		;<== 4 ALLOCATION UNITS FOR DIRECTORY
	DW	0		;NO DIRECTORY CHECK VECTOR
	DW	2		;SPACE FOR 2 SYSTEM TRACKS
	ENDIF
;
;	DEFINE MEMORY DISK STUFF IF WE ARE USING IT
;
	IF MD$USE
	DB	OC$DFMD		;OMNI COMMAND: DEFINE MEMORY DISK
;
;	ADDRESSES OF MEMORY DISK AREAS
;
	DB	MD$B1,MD$B1+MD$S1 ;MEMORY DISK BASE AND LAST BLOCK+1 -- GROUP 1
	DB	MD$B2,MD$B2+MD$S2 ;MEMORY DISK BASE AND LAST BLOCK+1 -- GROUP 2
	DB	MD$B3,MD$B3+MD$S3 ;MEMORY DISK BASE AND LAST BLOCK+1 -- GROUP 3
	DB	MD$B4,MD$B4+MD$S4 ;MEMORY DISK BASE AND LAST BLOCK+1 -- GROUP 4
;
;	MEMORY DISK DPB
;
	DB	15		;LENGTH OF DPB
	DW	40H		;SPT	   8K BYTES PER "TRACK"
	DB	4,0FH		;BSH, BLM  2K ALLOCATION SIZE
	DB	MD$EXM		;EXM
	DW	MD$AL-1		;DSM	   MAXIMUM ALLOCATION UNIT NUMBER
	DW	MD$FILES-1	;DRM	   MAXIMUM EXTENT NUMBER (DIRECTORY)
	DW	MD$AL01		;AL0, AL1  BITS FOR ALLOC UNITS IN DIRECTORY
	DW	0		;CKS	   NO CKECK VECTOR
	DW	MD$SCYL		;OFF	   8K/"CYL" GIVES SPACE FOR SYSTEM
;
;	FLAG, WHICH IF NON-ZERO, CAUSES MEM DISK INIT.
;
	DB 0 ;**DEBUG** DB	1		;INIT MEMORY DISK
;
;	THE MEMORY DISK INIT CALLED FOR HERE IS ONLY DONE ONCE
;	PER POWER-ON.  (ON POWER-ON THE OMNIDISK RESETS ITS MEMORY-
;	DISK-HAS-BEEN-INIT FLAG; WHEN REQUESTED TO INIT, AS IS DONE
;	HERE, IF THE FLAG IS SET THE INIT IS IGNORED ELSE THE INIT
;	IS DONE AND THE FLAG IS SET.)
;
;	IT IS DONE THIS WAY IN ORDER TO PRESERVE THE MEMORY DISK
;	WHEN RESET IS USED, BUT STILL PROVIDE AUTOMATIC OPERATION
;	ON POWER-ON.
;
;	SETTING THE ABOVE "DB" TO 80H OVERRIDES THE ONCE-PER-POWER-ON
;	SWITCH AND DOES THE INIT UNCONDITIONALY.  BUT WE DON'T WANT
;	TO DO THAT HERE.
;
;	YOU HAVE NOT SEEN CP/M PERFORM UNTIL THE A: DISK IS A MEMORY DISK.
;
	ENDIF

CBLEND	EQU	$		;END OF LIST
	IF MPUBPORT OR SIO2A OR BIGZ10 OR BIGZ0
	XRA	A
	OUT	MPUBST
	OUT	MPUBST
	OUT	MPUBST
	MVI	A,40H	;RST 8251
	OUT	MPUBST
	MVI	A,0AEH	;MODE: 8 DATA BITS, NO PARITY, 16X BAUD FACTOR
	OUT	MPUBST
	MVI	A,37H	;CMD: SET RTS & DTR, RESET ERROR, ENABLE XMIT & RECIEVE
	OUT	MPUBST
	ENDIF

	IF MPUBPORT

;	THIS INIT IS NOT NECESSARY IF USING SIO SERIAL PORT.
;	IT IS INCLUDED HERE TO INIT THE MPU-B PORT.
;
;	BAUD
;	RATE			3MHZ	6MHZ
;	----			----	----
;      19200	BAUD	EQU	****	0013
;	9600	 		0013
;	4800			0028
;	2400			0052
;	1200			0104	0208
;	 600			0208
;	 300			0416
;	 150			0833
;	134.5			0929
;	110			1136
;	 75			1666
;	 45			2777
;
BAUD	EQU	208		;<== SET FOR DESIRED BAUD RATE
;
;	INIT 8251 UART ON MPU-B
;	(COMMAND SEQUENCE RECOMMENDED BY IMSAI)
;

;	ASSUME MPU-B IS THE CPU. SAVE THE RAM LOCATIONS THAT
;	WERE LOADED BY THE BOOT BEFORE MAPPING THE MPU-B TO SET
;	THE BAUD (PRECAUTIONARY STEPS)?

	LXI	H,0D100H
	MOV	D,M		;SAVE WHAT'S THERE
	MVI	L,3		;HL=D103
	MOV	E,M		;SAVE WHAT'S THERE
	MVI	A,40H
	OUT	0F3H		;INSTALL MPU-B AT D800H
;	MVI	M,36H	;**	;HL=D103 MODE BYTE = 36H
	MVI	A,36H	;** (WOOPS, WE NEED THE EXTRA DELAY
	MOV	M,A	;**  TO ALLOW THE MPUB TO SWITCH)
	MVI	L,0		;HL=D100
	MVI	M,BAUD AND 0FFH	;BAUD LOW BYTE
	MVI	M,BAUD/256	;BAUD HIGH BYTE
	IN	0F3H		;TAKE OUT MPU-B

;	NOTE: THE CODE FROM 'OUT 0F3H' TO HERE MUST RESIDE EITHER
;	ABOVE OR BELOW THE FOLLOWING MAPPED MPU-B LOCATIONS.
;	    RAM AT D000H TO D0FFH
;	    PROM AT D800H TO DFFFH
;	    TIMERS AT D100H TO D103H

;	RESTORE RAM LOCATIONS
	MOV	A,D
	MOV	M,A		;RESTORE D100
	MVI	L,3
	MOV	M,E		;RESTORE D103
	ENDIF
;
;	MPUZ INIT
;
	IF RDRPUN
	MVI A,02AH ! OUT CRB	;RESET RECIEVER ON PORT B, DISABLE TX & RX
	MVI A,030H ! OUT CRB	;RESET TRANSMITTER ON PORT B
	MVI A,080H ! OUT ACR	;BAUD RATE SET#2, 1MHZ COUNTER, NO IP0..3 INTS
	MVI A,066H ! OUT CSRB	;PORT B IS 1200 BAUD
;	MVI A,0BBH ! ;OUT CSRB	;PORT B IS 9600 BAUD
	MVI A,015H ! OUT CRB	;SELECT MR1B, ENABLE PORT B XMIT AND RECIEVE
	MVI A,093H ! OUT MRB	;PORT B: RTS CONTROL, 8 BITS, NO PARITY
	MVI A,027H ! OUT MRB	;PORT B: FULL DUPLEX, RTS, NO CTS, 1 STOP BIT
	ENDIF

	IF MPUZPAR
	MVI	A,0F0H		;INIT PORT C DATA
	OUT	PARAA
	MVI	A,0A2H		;MODE 1, PORTS A & C ARE OUTPUT, B IS INPUT 
	OUT	PARACTL
	MVI	A,0BH		;SET PORT C BIT 5
	OUT	PARACTL		;?? WHATEVER FOR ??
	ENDIF
;
;	SIO INIT
;
	IF SIO40B
	XRA	A
	OUT	45H
	OUT	45H
	OUT	45H
	MVI	A,40H		;RST 8251
	OUT	45H
	MVI	A,0AEH		;MODE: 8 DATA BITS, NO PARITY, 16X BAUD FACTOR
	OUT	45H
	MVI	A,27H
	OUT	45H
	ENDIF

	IF 	CCS2810
;
; WHEN THE AUTO-BOOT JUMPER IS ENABLED, THE 2810
;  SERIAL PORT WILL BE INITIALIZED TO 9600 BAUD.
;  TO SELECT A DIFFERENT BAUD RATE, CHANGE SBAUD
;  TO ONE OF THE FOLLOWING VALUES:
;
;     BAUD RATE		SBAUD
;	50		2304
;	75		1536
;	110		1047
;	134.5		857
;	150		768
;	300		384
;	600		192
;	1200		96
;	1800		64
;	2000		58
;	2400		48
;	3600		32
;	4800		24
;	7200		16
;	9600		12
;	19200		6
;	38400		3
;	56000		2
;
SBAUD:	EQU	12	;4800 BAUD DIVISOR FOR 2810
;


	MVI	A,0FH		;SET MODEM CONTROL REGISTER
	OUT	SMDMCT
	MVI	A,83H		;SET BAUD RATE DIVISOR ACCESS
	OUT	SLCTRL
	LXI	H,SBAUD		;CONSOLE BAUD RATE DIVISOR
	MOV	A,H
	OUT	SINTEN
	MOV	A,L
	OUT	SDATA		;SET DIVISOR LOW BYTE
	MVI	A,3		;SET 8250 LINE CONTROL
	OUT	SLCTRL
	XRA	A		;SET HANDSHAKE LINES ACTIVE
	OUT	SINTEN
	OUT	SLSTAT
	ENDIF
;
;	ISSUE SIGN ON MESSAGE
;
	LXI	H,SIGNON
	CALL	OUTM
;
;	IF THE BIOS IS CONFIGURED TO SETUP THE VIOX CLOCK, THEN THE
;	MPUZ CLOCK IS NOW SENT TO THE VIOX (1BH,'>' ENDS SIGNON MSG)
;
	IF VIOXTIME		;SET VIOX CLOCK FROM MPUZ CLOCK
;
; NOTE:	IN ORDER TO SAVE SPACE, NEITHER STATUS PORT NOR SAME-SECONDS CHECKS
;	ARE MADE.  THIS CODE WILL WORK 99+% OF THE TIME WITHOUT THEM.
;
; NOTE:	THE MPUZ CLOCK IS ASSUMED TO BE IN THE 24-HOUR MODE.
;
;	IF THE MPUZ CLOCK IS IN THE AM/PM MODE, THEN THE VIOX CLOCK
;	WILL BE WRONG IF SET FROM 1:00 PM TO 12:59 AM THE NEXT MORNING.
;	
	LXI	H,0533H		;<H>=DIGIT ADRS & LOOP COUNT; <L>=INIT MASK
VTIME1	MOV	A,H
	OUT	CADR		;ADDRESS THE DESIRED DIGIT
	IN	CDATA		;ACCEPT 1111VVVV (WHERE VVVV IS CLOCK VALUE)
	ANA	L		;1111VVVV ==> 001100VV FOR 10'S OF HOURS
	MVI	L,3FH		;CHNG ABOVE TO 0011VVVV FOR OTHER CLOCK VALUES
	MOV	C,A
	CALL	IOCONOUT
	DCR	H
	JP	VTIME1		;IF MORE DIGITS TO GET
	ENDIF
;
;	IF NDISKS > 4 THEN ASMDPH WILL BE FALSE AND THE DPH TABLE
;	AS ASSEMBLED SOME PAGES BACK IS OVERLAYED WITH THE SIGNON
;	MESSAGE AND OTHER COLD BOOT CODE.
;
;	IF NDISKS < 5 THEN THE SYSTEM SIZE (AS WRITTEN TO THE SYSTEM
;	TRACKS) IS SMALLER IF WE DON'T GET FANCY.  IN THIS CASE WE
;	SIMPLY DON'T OVERLAY THE DPH TABLE.
;
	IF ASMDPH		;** SIMPLE
	JMP	GOCPM		;** STUFF FOR
	ENDIF			;** SMALL SYSTEMS

ADPHX	EQU	($+6-DPHEND)/8000H   ;NOTE: THE "+6" IS THE LENGTH OF 2 LXI'S
ADPHY	EQU	DPHEND-6-$
ADPHZ	EQU	(ADPHY-3)/8000H	;USED ONLY IF "NOT ASMDPH", SEE BELOW

	IF NOT ASMDPH		;ELSE...LET'S GET TRICKY AND REDUCE BOOT LENGTH
GENDPH	LXI	B,DPHGENT	;DPH GENERATOR TABLE
	LXI	H,DPHBASE	;WHERE GENERATED DPH GOES
	ENDIF

;******************************************************************************
;
;	THE FOLLOWING CONDITIONAL ASSEMBLY ASSURES THAT THE DPH GENERATOR
;	WILL NOT OVERLAY ITSELF AS IT RUNS.
;
;	WITH THE SIGNON MESSAGE AS RELEASED AND MPUBPORT=FALSE THIS
;	SECTION DOES NOTHING UNLESS NDISKS>14.  WITH MPUBPORT=TRUE
;	THIS SECTION DOES NOTHING UNLESS NDISKS>11.
;

	IF NOT ASMDPH AND ADPHX AND ADPHZ
	NOP ! NOP		;USE NOP'S IF NO ROOM TO ASSEMBLE JMP
	ENDIF

	IF NOT ASMDPH AND ADPHX AND NOT ADPHZ
	JMP	GDPH1		;USE JMP IF WE HAVE ROOM
	ENDIF

	IF NOT ASMDPH AND ADPHX
	ORG	DPHEND		;PUT FOLLOWING CODE WHERE IT WON'T GET ZAPPED
	ENDIF

;******************************************************************************

	IF NOT ASMDPH
GDPH1	LDAX	B
	INX	B
	ORA	A
	JM	GOCPM		;IF ALL DPH SLOTS ARE GENERATED
	LXI	D,8
	DAD	D		;<HL>=DPH PLACE FOR DIRBUF ADDRESS
	MVI	M,DIRBUF-DIRBUF/256*256
	INX	H
	MVI	M,DIRBUF/256
	INX	H
	MVI	E,15		;<DE>=LENGTH OF DPB -- NOTE: <D>=0
	CALL	GDPHSUB		;DPB ADDRESS TO DPH
	MOV	E,A		;<DE>=LENGTH OF CHECK VECTOR -- NOTE: <D>=0
	CALL	GDPHSUB		;CHECK VECTOR ADDRESS TO DPH
	LDAX	B	
	INX	B
	MOV	E,A		;LOW BITS OF ALLOCATION VECTOR LENGTH
	LDAX	B
	INX	B
	MOV	D,A		;<DE>=LENGTH OF ALLOCATION VECTOR
	CALL	GDPHSUB		;ALLOCATION VECTOR ADDRESS TO DPH
	JMP	GDPH1

GDPHSUB	PUSH	D
	LXI	D,DIRBUF+128	;WARNING: INSTRUCTION IS MODIFIED
GDPHSA	EQU	$-2
	MOV	M,E		;** TABLE
	INX	H		;** ADDRESS
	MOV	M,D		;** TO
	INX	H		;** DPH
	XTHL			;ENTRY <DE> TO <HL>
	XCHG			;ENTRY <DE> RESTORED, TBL ADRS TO <HL>
	DAD	D		;<HL>=NEXT TABLE ADDRESS...
	SHLD	GDPHSA		;...SAVE IN LXI INSTRUCTION
	POP	H		;RESTORE <HL> AS INCREMENTED
	RET
	ENDIF

DPHGENT:			;DPH GENERATOR TABLE

	IF NOT ASMDPH AND (NDISKS+99)/100	;FOR DRIVE 0 ( A: )
	DB	CKV$A
	DW	ALV$A
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/101	;FOR DRIVE 1 ( B: )
	DB	CKV$B
	DW	ALV$B
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/102	;FOR DRIVE 2 ( C: )
	DB	CKV$C
	DW	ALV$C
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/103	;FOR DRIVE 3 ( D: )
	DB	CKV$D
	DW	ALV$D
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/104	;FOR DRIVE 4 ( E: )
	DB	CKV$E
	DW	ALV$E
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/105	;FOR DRIVE 5 ( F: )
	DB	CKV$F
	DW	ALV$F
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/106	;FOR DRIVE 6 ( G: )
	DB	CKV$G
	DW	ALV$G
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/107	;FOR DRIVE 7 ( H: )
	DB	CKV$H
	DW	ALV$H
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/108	;FOR DRIVE 8 ( I: )
	DB	CKV$I
	DW	ALV$I
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/109	;FOR DRIVE 9 ( J: )
	DB	CKV$J
	DW	ALV$J
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/110	;FOR DRIVE 10 ( K: )
	DB	CKV$K
	DW	ALV$K
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/111	;FOR DRIVE 11 ( L: )
	DB	CKV$L
	DW	ALV$L
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/112	;FOR DRIVE 12 ( M: )
	DB	CKV$M
	DW	ALV$M
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/113	;FOR DRIVE 13 ( N: )
	DB	CKV$N
	DW	ALV$N
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/114	;FOR DRIVE 14 ( O: )
	DB	CKV$O
	DW	ALV$O
	ENDIF

	IF NOT ASMDPH AND (NDISKS+99)/115	;FOR DRIVE 15 ( P: )
	DB	CKV$P
	DW	ALV$P
	ENDIF

	IF NOT ASMDPH
	DB	0FFH		;END OF DPHGENT LIST
	ENDIF

BOOTLEN	EQU	$-BSORG		;CP/M + CBIOS LEN TO LOAD FOR BOOTSTRAP

	IF	BOOTLEN/1A01H
 EQU   ; WARNING ... SYSTEM LONGER THAN 1A00H WILL NOT FIT ON SD DISKETTE
	ENDIF

CD$SPACE  EQU	(MSIZE*1024)-$ ;SPACE FOR ADDITIONAL CODE AT END OF BIOS

	IF	CD$SPACE / 8000H
CD$OVER	EQU	-CD$SPACE	;HOW MUCH YOU ARE OVER
 EQU 	;SEE LISTING FOR CODE SPACE REMAINING CONSIDERATIONS
	ENDIF

;--------------------------------------------------------
;-	END OF ONE-TIME EXECUTION CODE. 		-
;--------------------------------------------------------

	ORG	DSORG

;********************************************************
;	UN-INIT SCRATCH RAM AREA FOR BDOS USE		*
;********************************************************

DIRBUF	DS	128		;DIRECTORY BUFFER

	IF (NDISKS+99)/100	;DRIVE 0 ( A: )
TDPB$A	DS	15
TCKV$A	DS	CKV$A
TALV$A	DS	ALV$A
	ENDIF

	IF (NDISKS+99)/101	;DRIVE 1 ( B: )
TDPB$B	DS	15
TCKV$B	DS	CKV$B
TALV$B	DS	ALV$B
	ENDIF

	IF (NDISKS+99)/102	;DRIVE 2 ( C: )
TDPB$C	DS	15
TCKV$C	DS	CKV$C
TALV$C	DS	ALV$C
	ENDIF

	IF (NDISKS+99)/103	;DRIVE 3 ( D: )
TDPB$D	DS	15
TCKV$D	DS	CKV$D
TALV$D	DS	ALV$D
	ENDIF

	IF (NDISKS+99)/104	;DRIVE 4 ( E: )
TDPB$E	DS	15
TCKV$E	DS	CKV$E
TALV$E	DS	ALV$E
	ENDIF

	IF (NDISKS+99)/105	;DRIVE 5 ( F: )
TDPB$F	DS	15
TCKV$F	DS	CKV$F
TALV$F	DS	ALV$F
	ENDIF

	IF (NDISKS+99)/106	;DRIVE 6 ( G: )
TDPB$G	DS	15
TCKV$G	DS	CKV$G
TALV$G	DS	ALV$G
	ENDIF

	IF (NDISKS+99)/107	;DRIVE 7 ( H: )
TDPB$H	DS	15
TCKV$H	DS	CKV$H
TALV$H	DS	ALV$H
	ENDIF

	IF (NDISKS+99)/108	;DRIVE 8 ( I: )
TDPB$I	DS	15
TCKV$I	DS	CKV$I
TALV$I	DS	ALV$I
	ENDIF

	IF (NDISKS+99)/109	;DRIVE 9 ( J: )
TDPB$J	DS	15
TCKV$J	DS	CKV$J
TALV$J	DS	ALV$J
	ENDIF

	IF (NDISKS+99)/110	;DRIVE 10 ( K: )
TDPB$K	DS	15
TCKV$K	DS	CKV$K
TALV$K	DS	ALV$K
	ENDIF

	IF (NDISKS+99)/111	;DRIVE 11 ( L: )
TDPB$L	DS	15
TCKV$L	DS	CKV$L
TALV$L	DS	ALV$L
	ENDIF

	IF (NDISKS+99)/112	;DRIVE 12 ( M: )
TDPB$M	DS	15
TCKV$M	DS	CKV$M
TALV$M	DS	ALV$M
	ENDIF

	IF (NDISKS+99)/113	;DRIVE 13 ( N: )
TDPB$N	DS	15
TCKV$N	DS	CKV$N
TALV$N	DS	ALV$N
	ENDIF

	IF (NDISKS+99)/114	;DRIVE 14 ( O: )
TDPB$O	DS	15
TCKV$O	DS	CKV$O
TALV$O	DS	ALV$O
	ENDIF

	IF (NDISKS+99)/115	;DRIVE 15 ( P: )
TDPB$P	DS	15
TCKV$P	DS	CKV$P
TALV$P	DS	ALV$P
	ENDIF

DS$SPACE  EQU	(MSIZE*1024)-$ ;SPACE FOR ADDITIONAL UN-INIT MEM AT END OF BIOS

	IF	DS$SPACE / 8000H
DS$OVER	EQU	-DS$SPACE	;HOW MUCH YOU ARE OVER
 EQU 	;SEE LISTING FOR DS SPACE REMAINING CONSIDERATIONS
	ENDIF

	END
