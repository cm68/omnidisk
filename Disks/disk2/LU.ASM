;	SOURCE IS LU.ASM
;
;
;	PORT EQUATES
;
DATAPORT	EQU	0A0H
STATPORT	EQU	0A1H
INREADY		EQU	01H
OUTREADY	EQU	80H
;
;	OMNIDISK COMMAND EQUATES
;
OC$BOOT	EQU	0		;BOOT SYSTEM
*C$SWRT	EQU	1		;WRITE SYSTEM (INVERSE OF BOOT)
OC$MODE EQU	2		;DMA/IO MODE
OC$FMTV	EQU	3		;FORMAT/VERIFY FLOPPY TRACK
OC$DLDS EQU	4		;DEFINE LOGICAL DEVICE SET
OC$GLDS	EQU	5		;GET LOGICAL DEVICE SET
*C$FWRT	EQU	6       	;FORCE WRITE OF MODIFIED BUFFERS
*C$RSBP EQU	7		;RESET BOOT PHANTOM
*C$SKEW	EQU	8		;SET NON-STANDARD SKEW FACTOR
OC$UNIT	EQU	9		;SELECT (LOGICAL) UNIT
OC$TRAK	EQU	10		;SELECT TRACK
OC$RECD	EQU	11		;SELECT (LOGICAL) RECORD
OC$DADR	EQU	12		;SET DMA ADDRESS
OC$READ	EQU	13		;READ
OC$WRIT	EQU	14		;WRITE
OC$HEAD	EQU	15		;SET HEAD (HARD DISK ONLY)
*C$MOVM	EQU	16		;MOVE BLOCK OF MEMORY WITH DMA
OC$GDPB	EQU	17		;GET DPB (GET CP/M DPB FROM OMNI)
OC$DFMD	EQU	18		;DEFINE MEMORY DISK
*C$SSEK EQU	19		;NON-IMPYED SEEK (NOT USED IN BIOS)
*C$TIOR	EQU	20		;DEBUG READS FROM OMNI
*C$TIOW	EQU	21		;DEBUG WRITES TO OMNI
OC$GENS EQU	22		;GET GENERAL STATUS
OC$EXTS	EQU	23		;GET EXTENDED STATUS

;
;	CP/M FUNCTION CODES
;
ADRBIOSB EQU	0001H		;ADDRESS OF BASE OF BIOS
CPM	EQU	0005H		;CALL ADDRESS FOR ALL CP/M FUNCTIONS
CPM$CIN	EQU	1		;CONSOLE INPUT
CPM$COU	EQU	2		;CONSOLE OUTPUT
CPM$PRS	EQU	9		;PRINT STRING ON CONSOLE
CPM$RDS	EQU	13		;RESET DISK SYSTEM
;
;	ASCII CHARACTER EQUATES
;
CTLC	EQU	3
LF	EQU	0AH
CR	EQU	0DH

	PAGE

;	WHEN PROGRAM IS STARTED LOCATION 80H AND FOLLOWING
;	RECIEVES THE DATA FOLLOWING THE VERB IN THE FOLLOWING
;	FORMAT:
;
;	DB	ENDP-BGNP
; BGNP	DB	'PARAMETERS ALL SHIFTED TO UPPER CASE'
; ENDP	DB	0
;
;	THIS PROGRAM CHANGES THE LOGICAL TO PHYSICAL ASSIGNMENTS
;	USED BY THE OMNIDISK CONTROLLER.
;
;	PARAMETER FORMAT:
;
;	8$$$$ 5$$$$ W$$$$ X$
;
;	WHERE 8, 5, W AND X ARE KEY LETTERS FOR 8-INCH FLOPPY DISK,
;	5-INCH FLOPPY DISK, WINCHESTER (OR HARD) DISK AND EXTENDED
;	MEMORY DISK.  THE $$$$ FOLLOWING THE KEY LETTER IS TO BE
;	REPLACED BY THE DESIRED CP/M LOGICAL DISK UNIT. EXAMPLE:
;
;	8AB.. 5CD.. WE... XF
;	8AB 5CD WE XF		TRAILING PLACE HOLDERS MAY BE OMMITTED.
;
;	THIS IS THE CONFIGURATION THAT THE AUTHOR OF THIS SOFTWARE
;	IS USING AS THESE COMMENTS ARE BEING WRITTEN.
;
;	FOR A SYSTEM THAT BOOTS ON 5-INCH FLOPPIES AND THEN WANTS TO
;	CONTINUE RUNNING WITH THE HARD DISK AS A:
;
;	5AB WC			CONFIGURATION AS BOOTED
;	WA 5CB			TO SWAP A: WITH C:
;  OR	WA 5BC			OLD A: NOW B:, OLD B: NOW C:, OLD C: NOW A:
;
;	FOLLOWING EACH OF THE KEY LETTERS (8, 5, AND W) ARE 4 PLACES WHICH
;	REFERENCE THE PHYSICAL UNIT ADDRESS: DS1..DS4 FOR FLOPPIES AND
;	UNITS 0..3 FOR THE WINCHESTER DRIVE(S).
;
;	A FEW STRAY WARNINGS:
;
; ..	YOU CAN NOT REFERENCE PHYSICAL DRIVES THAT
;	ARE NOT ALL READY CONFIGURED IN YOUR BIOS.  IF YOU ADD AN 8-INCH
;	DRIVE TO A 5-INCH SYSTEM YOU WILL HAVE TO CHANGE AND THEN REASSEMBLE
;	YOUR BIOS.
;
; ..	THIS PROGRAM DOES NOT ALLOW YOU TO UNDEFINE A PHYSICAL UNIT
;	THAT IS DEFINED IN THE BIOS.  ANY UNMENTIONED PHYSICAL UNITS
;	ARE DEFINED AUTOMATICALLY TO THE LOWEST UNMENTIONED LOGICAL
;	UNITS.  THE AUTOMATIC ORDER IS 8", 5", WINCHESTER AND MEMORY.
;
; ..	YOU CAN NOT REFERANCE LOGICAL DRIVES WITH A HIGHER LETTER THAN
;	HAS BEEN ASSEMBLED INTO YOUR BIOS.
;
; ..	YOU CAN NOT HAVE THE SAME LOGICAL UNIT USED MORE THAN ONCE.
;
; ..	YOU WILL HAVE AN A: DISK.  THIS A: DISK MUST HAVE A SAME-SIZE
;	SYSTEM ON IT AS YOU ARE RUNNING (48K/64K SWAPS WILL NOT WORK).
;
; ..	DEPENDING ON THE BOOT METHOD, THE SYSTEM ON THE NEW A: DISK MAY BE
;	THE ONE THAT GETS BOOTED AFTER A RESET.  THIS COULD CAUSE A SITUATION
;	WHERE A POWER-DOWN WOULD BE REQUIRED IF THE NEW A: DISK HAS A BAD
;	(OR NO) SYSTEM ON IT.
;
	ORG	100H

	LHLD	ADRBIOSB	;ADDRESS OF BASE OF BIOS
	LXI	D,3*8		;OFFSET TO SELDRV
	DAD	D
	SHLD	SELDRV1		;MAKE JUMP INSTRUCTION TO GO TO SELDRV IN BIOS

	CALL	SINPUT		;SCAN INPUT FOR REQUESTED CONFIGURATION
	CALL	GETLUS		;GET (CURRENT) LU ASSIGNMENTS FROM CONTROLLER
	CALL	ADDUML		;ADD UN-MENTIONED LU'S TO INPUT
	CALL	GETDPH		;GET ALL DPH'S FROM BIOS
	CALL	PUTDPH		;PUT ALL DPH'S BACK TO BIOS
	CALL	PUTLUS		;PUT NEW LOGICAL-TO-PHYSICAL MAPPING TO ONMI

	MVI	C,CPM$RDS	;** RESET DISK SYSTEM TO FORCE
	CALL	CPM		;** RELOGGING OF ALL DISKS
;	RST	7
	JMP	0000		;DONE

;	SINPUT - SCAN INPUT LINE
;
;	BUILDS RLU AND USEDLU TABLES
;
SINPUT:
	LXI	H,81H
;
;	HERE WE SCAN FOR 8,5,W,X IGNORING ALL SPACES, EXITING ON 00H
;
SIN1	MOV	A,M		;FETCH BYTE FROM INPUT LINE
	INX	H
	CPI	' '
	JZ	SIN1		;IF A BLANK WHICH WE IGNORE
	ORA	A
	RZ			;IF TERMINATOR FOUND
	MVI	C,4		;NUMBER OF DISKS OF GIVEN TYPE
	LXI	D,RLU+00H	;SET FOR 8" FLOPPY
	CPI	'8'
	JZ	SIN3
	LXI	D,RLU+04H	;SET FOR 5" FLOPPY
	CPI	'5'
	JZ	SIN3
	LXI	D,RLU+08H	;SET FOR WINCHESTER
	CPI	'W'
	JZ	SIN3
	LXI	D,RLU+0CH	;SET FOR EXTENDED MEMORY "DISK"
	MVI	C,1		;THERE IS ONLY ONE MEMORY DISK
	CPI	'X'
	JZ	SIN3
	JMP	INERROR
;
;	HERE WE HAVE <C> = NUMBER OF DISKS OF GIVEN TYPE LEFT
;		    <DE> = ADDRESS WITHIN RLU TO SET
;		    <HL> = ADDRESS WITHIN INPUT TEXT
;
SIN2	INX	D
	DCR	C
	JM	INERROR
	INX	H
SIN3	MOV	A,M
	CPI	'.'
	JZ	SIN2
	CPI	'A'
	JC	SIN1		;IF INPUT < 'A' WE RETURN TO MAIN SCAN
	CPI	'P'+1
	JNC	SIN1		;IF INPUT > 'P' WE RETURN TO MAIN SCAN
	SUI	'A'		;CONVERT LETTERS A..P INTO NUMBERS 00H..0FH
	MOV	B,A
	LDAX	D
	ORA	A
	JP	INERROR		;IF DEVICE GIVEN LOGICAL UNIT BEFORE
	MOV	A,B
	STAX	D		;SAVE IN RLU
;
;	HERE WE MARK THE LU USED TABLE
;
	PUSH	B
	PUSH	H
	MVI	B,0
	MOV	C,A		;<BC>=LOGICAL UNIT 0..F FOR A: .. A:
	LXI	H,USEDLU
	DAD	B
	MOV	A,M		;<A>=0 IF LU NOT USED BEFORE
	ORA	A
	JNZ	ERROR
	MOV	M,H		;MARK LU AS USED
	POP	H
	POP	B
;
	JMP	SIN2		;GET NEXT BYTE FROM INPUT

;	GETLUS - GET ALL LOGICAL UNITS
;
;	RETURNS TWO LISTS:
;
;	  PTOL (PHYSICAL TO LOGICAL)
;		BYTES 0..3 8" FLOPPY DEVICES 0..3
;		BYTES 4..7 5" FLOPPY DEVICES 0..3
;		BYTES 8..11 HARD DISK DEVICES 0..3
;		BYTE 12 MEMORY DISK
;	  TABLE CONTAINS 00H FOR UNUSED PHYSICAL DEVICE -OR-
;	  'A' .. 'P' FOR LOGICAL UNIT.
;
;	  LTOP (LOGICAL TO PHYSICAL)
;		16 BYTES IN LENGTH FOR LOGICAL DEVICES A: .. P:
;		CONTENT IS --
;		  ZERO FOR UNDEFINED LOGICAL DEVICE
;		  10H..13H FOR 8" FLOPPIES
;		  14H..17H FOR 5" FLOPPIES
;		  18H..1BH FOR THE HARD DISK
;		  1CH FOR THE MEMORY DISK
;
GETLUS:
	LXI	H,PTOL		;BEGIN BY ZEROING PTOL
	MVI	C,13		;NUMBER OF ENTRIES
GLU1	MVI	M,0
	INX	H
	DCR	C
	JNZ	GLU1		;IF NOT DONE ZEROING PTOL

	LXI	H,LTOP+0FH
	SHLD	GLUB		;POINTER TO WITHIN LTOP
	MVI	A,0FH		;LOGICAL UNIT P:
	STA	GLUA		;...TO COMMAND LIST
GLU2	CALL	OUTLIST
	DB	2		;LENGTH OF LIST
	DB	OC$GLDS		;OMNI COMMAND: GET LOGICAL DEVICE SET
GLUA	DB	0		;PLUGGED WITH LOGICAL UNIT
	CALL	INCHAR		;GET PHYSICAL DEVICE
	ORA	A
	JP	GLU4		;IF DEVICE SET NOT IN USE
	PUSH	PSW
GLU3	CALL	INCHAR
	ORA	A
	JM	GLU3		;IF MORE PHYSICAL DEVICES
	POP	PSW
GLU4	LHLD	GLUB
	MOV	M,A		;STORE PHYSICAL DEVICE INTO LTOP ENTRY
	DCX	H
	SHLD	GLUB		;ADDRESS READY FOR NEXT (ONE LOWER) LU
	JZ	GLU5		;IF LOGICAL ADDRESS IS EMPTY
	MVI	D,0
	MOV	E,A		;<DE> = PHYSICAL DEVICE CODE
	LXI	H,PTOL-10H
	DAD	D		;FOR ADDRESS OF PTOL SLOT
	LDA	GLUA
	ADI	'A'
	MOV	M,A		;POST LOGICAL DEVICE CODE ==> PTOL
GLU5	LXI	H,GLUA
	DCR	M		;NEXT (LOWER) LOGICAL UNIT
	JP	GLU2		;IF MORE LOGICAL UNITS TO GO
	RET			;ELSE DONE

GLUB	DS	2		;ADDRESS WITHIN LTOP


;	ADDUML - ADD UNMEMTIONED PHYSICAL UNITS
;
;	SCANS PTOL/RLU LOOKING FOR EMPTY ENTRY IN RLU
;	UPON FINDING ONE, THE USEDLU LIST IS SCANNED
;	FOR THE FIRST UNUSED LOGICAL UNIT WHICH IS THEN ASSIGNED.

ADDUML:
	LXI	D,PTOL
	LXI	H,RLU
ADU1	LDAX	D
	ORA	A	
	JZ	ADU3		;IF NO SUCH PHYSICAL UNIT
	MOV	A,M
	ORA	A
	JP	ADU3		;IF PHYSICAL UNIT WAS GIVEN IN INPUT
	PUSH	H
	LXI	H,USEDLU-1
	MVI	B,0FFH
ADU2	INX	H
	INR	B		;LOGICAL UNIT: 0..F FOR A: .. P:
	MOV	A,M
	ORA	A
	JNZ	ADU2		;IF LU HAS BEEN USED
	MOV	M,H		;MARK LOGICAL UNIT AS HAVING BEEN USED

	POP	H		;POSITION WITHIN RLU
	MOV	M,B		;LU WE JUST FOUND

ADU3
	INX	H
	INX	D
	INR	C
	MVI	A,0CH
	CMP	C
	JNC	ADU1		;IF NOT PAST MEMORY DISK (OUR LAST UNIT)
	RET


;	GETDPH --  GET ALL DPH'S FROM BIOS
;
;

GETDPH:	LXI	H,RLU+13	;LBA+1 OF RLU
	MVI	C,0DH		;LAST+1 PHYSICAL UNIT
GETDPH1 DCX	H
	DCR	C		;PHYSICAL UNIT
	RM			;IF DONE WITH SCAN
	MOV	A,M
	ORA	A
	JM	GETDPH1		;IF PHYSICAL UNIT NOT MENTIONED IN INPUT
	PUSH	H
	PUSH	B
	MOV	L,A		;LOGICAL UNIT AS GIVEN IN INPUT
	MVI	H,0
	DAD H ! DAD H ! DAD H ! DAD H
	LXI	D,DPHTAB
	DAD	D		;<HL>=ADDRESS W/I DPHTAB FOR DPH FROM SYSTEM
	PUSH	H
	MVI	B,0		;<BC>=PHYSICAL UNIT
	LXI	H,PTOL
	DAD	B
	MOV	A,M		;CURRENT LOGICAL UNIT 'A'..'P' OR 00H IF NONE
	SUI	'A'
	JM	ERROR		;IF REQUESTED PHYSICAL UNIT NOT PRESENT
	CALL	SELDRV
	MOV	A,H
	ORA	L
	JZ	ERROR		;IF LOGICAL NOT ACCESSABLE FROM BIOS
	POP	D		;ADDRESS WITHIN DPH
	MVI	C,16
GETDPH2	MOV	A,M		;DPH BYTE FROM BIOS...
	STAX	D		;...TO OUR OWN DPHTAB
	INX	H
	INX	D
	DCR	C
	JNZ	GETDPH2		;IF MORE TO MOVE
	POP	B		;RESTORE PHYSICAL UNIT FOR SCAN
	POP	H		;RESTORE RLU ADDRESS FOR SCAN
	JMP	GETDPH1

;
;	PUTDPH -- PUT ALL DPH'S BACK TO BIOS
;
PUTDPH:
	MVI	B,0		;FIRST LOGICAL UNIT TO DEFINE
	LXI	D,DPHTAB
PUTDPH1	MOV	A,B		;LOGICAL UNIT
	INR	B		;GET READY FOR NEXT UNIT
	CPI	10H
	RNC			;IF PAST LOGICAL UNIT P:
	CALL	SELDRV
	MOV	A,H
	ORA	L
	JZ	PUTDPH1		;IF LOGICAL UNIT NOT DEFINED -- TRY NEXT
	MVI	C,16		;LENGTH OF DPH
PUTDPH2	LDAX	D		;OUR DPHTAB BYTE...
	MOV	M,A		;...TO DPH IN BIOS
	INX	D
	INX	H
	DCR	C
	JNZ	PUTDPH2		;IF MORE DPH TO MOVE
	JMP	PUTDPH1		;DONE WITH MOVE -- GO CHECK FOR ANOTHER GROUP
;
;	PUTLUS - PUT NEW LOGICAL-TO-PHYSICAL MAPPING TO OMNI
;
PUTLUS:
;
;	FIRST DEFINE AWAY ALL LOGICAL-TO-PHYSICAL MAPPINGS
;
	CALL	OUTLIST
	DB	16*3		;LENGTH OF LIST
	DÂ	OC$DLDS,00H,0,OC$DLDS,01H,0,OC$DLDS,02H,0,OC$DLDS,03H,0
	DÂ	OC$DLDS,04H,0,OC$DLDS,05H,0,OC$DLDS,06H,0,OC$DLDS,07H,0
	DÂ	OC$DLDS,08H,0,OC$DLDS,09H,0,OC$DLDS,0AH,0,OC$DLDS,0BH,0
	DÂ	OC$DLDS,0CH,0,OC$DLDS,0DH,0,OC$DLDS,0EH,0,OC$DLDS,0FH,0

	MVI	B,13		;NUMBER OF PHYSICAL DEVICES
	LXI	D,RLU
	LXI	H,PUTLUSB
PUTLUS1	LDAX	D
	ORA	A
	JM	PUTLUS2		;DONT DEFINE UNMAPPED LOGICAL UNIT
	STA	PUTLUSA		;PLUG LOGICAL MAPPING

	CALL	OUTLIST
	DB	3		;LENGTH OF LIST
	DB	OC$DLDS		;DEFINE LOGICAL DEVICE SET
PUTLUSA	DB	$-$		;LOGICAL DEVICE		(BOTH OF THESE ARE
PUTLUSB	DB	10H		;PHYSICAL MAPPING	 CHANGED IN THE LOOP)

PUTLUS2	INR	M		;NEXT PHYSICAL DEVICE
	INX	D		;ADRS OF NEXT LOGICAL DEVICE
	DCR	B
	JNZ	PUTLUS1		;IF MORE LIST TO PROCESS
	RET			;ELSE...DONE

;
;	SELDRV -- ACCESS BIOS SELDRV FUNCTION
;
;	ENTRY	<A>  = LOGICAL UNIT NUMBER (00H .. 0FH FOR A: .. P:)
;
;	RETURNS <HL> = DPB ADDRESS FOR LOGICAL UNIT (OR 0000 IF NONE)
;		<BC> UNCHANGED
;		<DE> UNCHANGED
;
SELDRV	PUSH	B
	PUSH	D
	MOV	C,A		;LU NUMBER
	MVI	E,1		;DONT ACCESS DRIVE
	CALL	$-$
SELDRV1	EQU	$-2
	POP	D
	POP	B
	RET

INERROR:
ERROR:	MVI	C,CPM$PRS	;PRINT STRING ON CONSOLE
	LXI	D,MSG
	CALL	CPM
	JMP	0000

MSG	DB	'INCORRECT INPUT$'

;******************************************************************************
;
;	SUBROUTINES TO TALK WITH OMNIDISK
;
;******************************************************************************

OUTLIST:
	XTHL
	MOV	C,M		;FETCH LENGTH OF LIST
	INX	H
OUTLIST1:
	IN	STATPORT
	ANI	OUTREADY
	JNZ	OUTLIST1	;IF OMNI NOT READY FOR COMMAND
	MOV	A,M		;NEXT BYTE TO SEND
	INX	H
	OUT	DATAPORT
	DCR	C
	JNZ	OUTLIST1	;IF MORE COMMANDS TO SEND
	XTHL
	RET

OUTCHAR:
	PUSH	PSW
OUTCHAR1:
	IN	STATPORT
	ANI	OUTREADY
	JNZ	OUTCHAR1
	POP	PSW
	OUT	DATAPORT
	RET
INCHAR:
	IN	STATPORT
	ANI	INREADY
	JZ	INCHAR
	IN	DATAPORT
	RET

;********************************************************
;	SUBROUTINE FOR BLOCK READ			*
;							*
;	NOTE:	THIS SUBROUTINE READS DATA UNTIL	*
;		THE OMNI CONTROLLER ACCEPTS THE		*
;		GENERAL STATUS COMMAND			*
;							*
;	ALSO....BYTES READ TO MEMORY ARE COUNTED IN <C>	*
;							*
;********************************************************

GETDAT:	MVI	C,0
GETDAT0 IN	STATPORT
	RRC
	JNC	GETDAT0		;IF NOTHING TO GET FROM OMNI
	ANI	40H		;(WHAT DO WE HAVE HERE: DATA -OR- GEN STATUS?)
	IN	DATAPORT	;TAKE IT, WHATEVER IT IS
	RZ			;IF IT IS GENERAL STATUS, THEN RETURN
	MOV	M,A		;ELSE...PUT INTO BUFFER
	INX	H
	INR	C
	JMP	GETDAT0		;KEEP ON KEEPING ON

;		A B C D E F G H I J K L M N O P
USEDLU	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

;	LOGICAL UNITS FROM THE INPUT LINE REPLACE THE -1'S IN THIS LIST
;
;		 8 INCH	     5 INCH
;		 FLOPPY      FLOPPY	 HARD DISK   +MEMORY DISK
;		 ----------  ----------  ----------  v
;		 1  2  3  4  1  2  3  4  0  1  2  3  .
RLU	DB	-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1

;******************************************************************************
;
;	  PTOL (PHYSICAL TO LOGICAL)
;		BYTES 0..3 8" FLOPPY DEVICES 0..3
;		BYTES 4..7 5" FLOPPY DEVICES 0..3
;		BYTES 8..11 HARD DISK DEVICES 0..3
;		BYTE 12 MEMORY DISK
;	  TABLE CONTAINS 00H FOR UNUSED PHYSICAL DEVICE -OR-
;	  'A' .. 'P' FOR LOGICAL UNIT.
;
PTOL	DS	13
;
;	  LTOP (LOGICAL TO PHYSICAL)
;		16 BYTES IN LENGTH FOR LOGICAL DEVICES A: .. P:
;		CONTENT IS --
;		  ZERO FOR UNDEFINED LOGICAL DEVICE
;		  10H..13H FOR 8" FLOPPIES
;		  14H..17H FOR 5" FLOPPIES
;		  18H..1BH FOR THE HARD DISK
;		  1CH FOR THE MEMORY DISK
;
LTOP	DS	16

DPHTAB	DS	16*16		;A: TO P: AT 16 BYTES PER ENTRY

	END
